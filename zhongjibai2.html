<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Ti·∫øng Trung: Êàë‰∏çÂêÉËøô‰∏™ üêº (vFinal)</title>
    <style>
        /* ----- CSS ----- */
        body { font-family: sans-serif; line-height: 1.6; background-color: #f0f8ff; display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 20px; margin: 0; }
        #game-container { background-color: #ffffff; padding: 30px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); max-width: 800px; width: 100%; text-align: center; box-sizing: border-box; }
        h1 { color: #ff6347; margin-top: 0; }
        #timer-section { font-size: 1.2em; font-weight: bold; margin-bottom: 15px; color: #4682b4; }
        #instructions p { background-color: #e0f7fa; border-left: 5px solid #00bcd4; padding: 15px; border-radius: 5px; margin-bottom: 20px; text-align: left; font-size: 1.1em; }
        #game-area { margin-bottom: 20px; text-align: left; }

        .stage-title { font-size: 1.5em; color: #007bff; margin-bottom: 15px; text-align: center; }
        #vocab-matching-area { display: flex; justify-content: space-around; margin-bottom: 20px; min-height: 300px; }
        .vocab-list-column, .meaning-list-column { width: 45%; padding: 10px; border: 1px dashed #ccc; border-radius: 5px; }
        .draggable-word { background-color: #fffacd; padding: 8px 12px; margin: 5px 0; border-radius: 5px; cursor: grab; border: 1px solid #eee; text-align: center; }
        .meaning-target { background-color: #e0f7fa; padding: 15px 12px; margin: 5px 0; border-radius: 5px; border: 1px dashed #00bcd4; min-height: 30px; display: flex; align-items: center; justify-content: center; }
        .meaning-target.over { border-style: solid; background-color: #cceeff; }
        .meaning-target.dropped-correct .draggable-word { background-color: #d4edda; color: #155724; cursor: default; }
        .meaning-target.dropped-incorrect .draggable-word { background-color: #f8d7da; color: #721c24; }
        .fill-sentence { margin-bottom: 10px; font-size: 1.1em; }
        .fill-sentence select { padding: 5px; font-size: 1em; margin: 0 5px; border-radius: 4px; }
        .sentence-completion-item { margin-bottom: 15px; }
        .sentence-completion-item label { display: block; margin-bottom: 5px; font-weight: normal; }
        .sentence-completion-item textarea, .sentence-completion-item input[type="text"] { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; min-height: 30px; }
        #reading-passage { background-color: #f8f9fa; padding: 15px; border-radius: 5px; margin-bottom: 20px; line-height: 1.7; text-align: left; max-height: 300px; overflow-y: auto;}
        /* CSS cho ƒë·ªãnh d·∫°ng ƒëo·∫°n ƒë·ªçc hi·ªÉu m·ªõi */
        #reading-passage p { margin-bottom: 0.8em !important; /* TƒÉng kho·∫£ng c√°ch gi·ªØa c√°c l∆∞·ª£t l·ªùi */ }
        .reading-narrative { color: grey; font-style: italic; margin-bottom: 10px !important; }
        .speaker-line strong { font-weight: bold; }
        /* M√†u cho t·ª´ng nh√¢n v·∫≠t - b·∫°n c√≥ th·ªÉ ƒë·ªïi m√†u ·ªü ƒë√¢y */
        .speaker-zhangxiaowei { color: #007bff; } /* Xanh d∆∞∆°ng */
        .speaker-puzhihui { color: #28a745; } /* Xanh l√° */
        .speaker-shanxiaheye { color: #fd7e14; } /* Cam */
        .speaker-fengshangde { color: #6f42c1; } /* T√≠m */
        .speaker-chenxinyang { color: #d63384; } /* H·ªìng */
        .speaker-default { color: #343a40; } /* M√†u ch·ªØ b√¨nh th∆∞·ªùng n·∫øu kh√¥ng kh·ªõp */

        .reading-question { margin-bottom: 15px; }
        .reading-question label { display: block; margin-bottom: 5px; font-weight: normal; }
        .reading-question textarea { width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; min-height: 60px; }
        #sc-current-word-area { margin-bottom: 20px; padding: 15px; background-color: #fffacd; border-radius: 8px; text-align: center; }
        #sc-current-word-hanzi { font-size: 1.8em; font-weight: bold; display: block; margin-bottom: 5px;}
        #sc-current-word-pinyin { font-size: 1.1em; color: grey; display: block;}
        #sc-current-word-meaning { font-size: 1em; color: #555; display: block; margin-top: 5px; font-style: italic;}
        #sc-sentence-input { box-sizing: border-box; width: 100%; padding: 15px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 5px; min-height: 80px; margin-bottom: 15px; display: block; }
        #paragraph-writing-prompt { background-color: #e9ecef; padding: 15px; border-radius: 5px; margin-bottom: 10px; text-align: left; font-size: 0.9em;}
        #paragraph-writing-prompt h4 { margin-top: 0; }
        #paragraph-input { width: calc(100% - 22px); min-height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 4px; }
        #char-count { font-size: 0.9em; color: #6c757d; text-align: right; }
        #current-word-area { margin-bottom: 20px; padding: 15px; background-color: #fffacd; border-radius: 8px; text-align: center; }
        #current-word-hanzi { font-size: 1.8em; font-weight: bold; display: block; margin-bottom: 5px;}
        #current-word-pinyin { font-size: 1.1em; color: grey; display: block;}
        #current-word-meaning { font-size: 1em; color: #555; display: block; margin-top: 5px; font-style: italic;}
        #sentence-input { box-sizing: border-box; width: 100%; padding: 15px; font-size: 1.1em; border: 1px solid #ccc; border-radius: 5px; min-height: 80px; margin-bottom: 15px; display: block; }
        .paragraph-container { font-size: 1.2em; line-height: 1.8; margin-bottom: 20px; background-color: #f8f8f8; padding: 20px; border-radius: 8px; border: 1px solid #eee; text-align: left; }
        .blank-input { width: auto; min-width: 50px; border: none; border-bottom: 2px solid #4682b4; padding: 2px 5px; font-size: 1em; text-align: center; margin: 0 3px; background-color: transparent; vertical-align: baseline; }
        .new-word { color: red; font-weight: bold; cursor: pointer; position: relative; }
        .tooltip { display: none; position: absolute; background-color: #333; color: #fff; padding: 8px 12px; border-radius: 6px; font-size: 0.9em; z-index: 10; white-space: normal; max-width: 250px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); text-align: left; }
        .tooltip span { display: block; margin-bottom: 3px; }
        .tooltip span:last-child { margin-bottom: 0; }
        #hint-section { margin-bottom: 20px; }
        #hint-text { color: #6a5acd; font-style: italic; min-height: 20px; margin-top: 10px; }
        #feedback-section { margin-top: 15px; padding: 10px; border-radius: 5px; min-height: 30px; display: none; word-wrap: break-word; text-align: left; }
        #feedback-section.correct { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        #feedback-section.incorrect { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        #feedback-section.info { background-color: #cce5ff; color: #004085; border: 1px solid #b8daff; }
        button { background-color: #ff6347; color: white; border: none; padding: 12px 25px; border-radius: 25px; cursor: pointer; font-size: 1em; transition: background-color 0.3s ease, transform 0.1s ease; margin: 10px 5px 5px 5px; }
        button:hover { background-color: #e5533d; }
        button:active { transform: scale(0.98); }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #summary-page { background-color: #e6f7ff; padding: 30px; border-radius: 10px; margin-top: 20px; text-align: left; display: none; }
        #summary-page h2 { text-align: center; color: #1890ff; }
        #summary-errors { padding-left: 20px; }
        #summary-errors li { color: #d9534f; margin-bottom: 5px; list-style: disc; }
        #summary-errors small { color: #555; }
        #submit-reminder { font-size: 1.25em; font-weight: bold; color: #856404; background-color: #fff3cd; padding: 15px; border-left: 6px solid #ffeeba; border-radius: 5px; margin-top: 25px; margin-bottom: 25px; text-align: center; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Game Ti·∫øng Trung: Êàë‰∏çÂêÉËøô‰∏™ ü•¢</h1>
        <div id="timer-section">‚è≥ Th·ªùi gian: <span id="timer">00:00</span></div>
        <div id="instructions"><p>üíñ Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi b√†i h·ªçc "T√¥i kh√¥ng ƒÉn c√°i n√†y"! H√£y c√πng kh√°m ph√° nh√©!</p></div>
        <div id="game-area"></div>
        <div id="hint-section"><button id="hint-button" class="hidden">üí° G·ª£i √Ω cho t√¥i n√†o!</button><p id="hint-text"></p></div>
        <div id="feedback-section"><p id="feedback-text"></p></div>
        <div id="navigation-buttons" style="margin-top: 20px; text-align: center;">
            <button id="next-stage-button" class="hidden" style="background-color: #17a2b8;">Ti·∫øp t·ª•c M√†n Sau ‚ñ∂Ô∏è</button>
            </div>
    </div>
    <div id="tooltip" class="tooltip"><span id="tooltip-hanzi"></span><span id="tooltip-pinyin"></span><span id="tooltip-meaning"></span></div>
    <div id="summary-page"><h2>üéâ Ho√†n Th√†nh! üéâ</h2><p>T√™n h·ªçc vi√™n: <span id="summary-player-name"></span></p><p>T·ªïng th·ªùi gian: <span id="summary-time"></span></p><p>S·ªë c√¢u ƒë√∫ng: <span id="summary-correct"></span> (T·ªïng s·ªë c√¢u h·ªèi: <span id="total-questions-summary"></span>)</p><p>S·ªë c√¢u sai: <span id="summary-incorrect"></span></p><h3>Chi ti·∫øt l·ªói sai:</h3><ul id="summary-errors"></ul><p id="submit-reminder">C√°c b·∫°n nh·ªõ ·∫•n n·ªôp k·∫øt qu·∫£ l√™n Google Form nh√©</p><button id="submit-report-button" style="background-color: #28a745;">N·ªôp B√°o C√°o L√™n Google Form üìã</button><button id="restart-button">Ch∆°i l·∫°i t·ª´ ƒë·∫ßu üîÅ</button></div>

    <script>
        // ----- D·ªÆ LI·ªÜU TR√í CH∆†I M·ªöI (Gi·ªØ nguy√™n t·ª´ l·∫ßn tr∆∞·ªõc) -----
        const vocabMatchingData = [ { id: 1, hanzi: 'Âèó‰∏ç‰∫Ü', pinyin: 'sh√≤ubuli«éo', meaning: 'kh√¥ng ch·ªãu n·ªïi / cannot stand/bear', type: 'word' }, { id: 2, hanzi: 'Ëæ£Ê§í', pinyin: 'l√†jiƒÅo', meaning: '·ªõt / chilli pepper', type: 'word' }, { id: 3, hanzi: 'È£üÁâ©', pinyin: 'sh√≠w√π', meaning: 'th·ª±c ph·∫©m, ƒë·ªì ƒÉn / food', type: 'word' }, { id: 4, hanzi: 'ÂåÖÊã¨', pinyin: 'bƒÅoku√≤', meaning: 'bao g·ªìm / include', type: 'word' }, { id: 5, hanzi: 'ÂÜÖËÑè', pinyin: 'n√®iz√†ng', meaning: 'n·ªôi t·∫°ng / internal organs', type: 'word' }, { id: 6, hanzi: 'Ê∏ÖÁúü', pinyin: 'qƒ´ngzhƒìn', meaning: '(ƒë·ªì ƒÉn) Halal / Muslim', type: 'word' }, { id: 7, hanzi: 'Á©ÜÊñØÊûó', pinyin: 'm√∫sil√≠n', meaning: 'ng∆∞·ªùi H·ªìi gi√°o / Muslim', type: 'word' }, { id: 8, hanzi: 'ËÇâÈ£ü', pinyin: 'r√≤ush√≠', meaning: 'th·ªãt (ƒÉn ƒë∆∞·ª£c) / edible meat', type: 'word' }, { id: 9, hanzi: 'ËøáÊïè', pinyin: 'gu√≤m«ên', meaning: 'd·ªã ·ª©ng / be allergic to', type: 'word' }, { id: 10, hanzi: 'È∏°Áà™Â≠ê', pinyin: 'jƒ´zhu«ézi', meaning: 'ch√¢n g√† / chicken\'s foot', type: 'word' }, { id: 11, hanzi: 'ÈªëÊöóÊñôÁêÜ', pinyin: 'hƒìi\'√†n li√†ol«ê', meaning: '"·∫©m th·ª±c b√≥ng t·ªëi" / dark cuisine', type: 'word' }, { id: 12, hanzi: 'Ê≤πËÖª', pinyin: 'y√≥un√¨', meaning: 'd·∫ßu m·ª°, ng·∫•y / oily', type: 'word' }, { id: 13, hanzi: 'ÁÉ§È±º', pinyin: 'k«éoy√∫', meaning: 'c√° n∆∞·ªõng / broiled/roast fish', type: 'word' }, { id: 14, hanzi: 'Ëî¨Ëèú', pinyin: 'sh≈´c√†i', meaning: 'rau c·ªß / vegetables', type: 'word' }, { id: 15, hanzi: 'Á¥†È£ü', pinyin: 's√πsh√≠', meaning: 'ƒë·ªì chay, ƒÉn chay / vegetarian meal', type: 'word' }, { id: 16, hanzi: 'ÂØºËá¥', pinyin: 'd«éozh√¨', meaning: 'd·∫´n ƒë·∫øn / lead to', type: 'word' }, { id: 17, hanzi: 'Ëê•ÂÖª', pinyin: 'y√≠ngy«éng', meaning: 'dinh d∆∞·ª°ng / nutrition', type: 'word' }, { id: 18, hanzi: '‰∏çË∂≥', pinyin: 'b√πz√∫', meaning: 'kh√¥ng ƒë·ªß / insufficient', type: 'word' }, { id: 19, hanzi: 'ÊãíÁªù', pinyin: 'j√πju√©', meaning: 't·ª´ ch·ªëi / refuse', type: 'word' }, { id: 20, hanzi: 'Ë∫´Êùê', pinyin: 'shƒìnc√°i', meaning: 'v√≥c d√°ng / stature; figure', type: 'word' }, { id: 21, hanzi: 'ÂÖÖÊª°', pinyin: 'ch≈çngm«én', meaning: 'tr√†n ƒë·∫ßy / be filled with', type: 'word' }, { id: 22, hanzi: 'ÂäõÈáè', pinyin: 'l√¨liang', meaning: 's·ª©c l·ª±c / physical strength', type: 'word' }, { id: 23, hanzi: 'Áñ≤Âä≥', pinyin: 'p√≠l√°o', meaning: 'm·ªát m·ªèi / tired', type: 'word' }, { id: 24, hanzi: 'È¶ôËèú', pinyin: 'xiƒÅngc√†i', meaning: 'rau m√πi / coriander', type: 'word' } ];
        const vocabFillData = { options: ["Âèó‰∏ç‰∫Ü", "Ëæ£Ê§í", "È£üÁâ©", "ÂåÖÊã¨", "ÂÜÖËÑè", "Ê∏ÖÁúü", "ËøáÊïè", "Ê≤πËÖª", "Ëî¨Ëèú", "Á¥†È£ü", "ÂØºËá¥", "Ëê•ÂÖª", "ÊãíÁªù", "È¶ôËèú"], sentences: [ { parts: ["ÂõõÂ∑ùÁÅ´ÈîÖÂ§™Ëæ£‰∫ÜÔºåÊàëÊúâÁÇπÂÑø ", { placeholderID: "vf_1", answer: "Âèó‰∏ç‰∫Ü" }, "„ÄÇ"] }, { parts: ["ÂæàÂ§öÂ§ñÂõΩ‰∫∫‰∏ç‰π†ÊÉØÂêÉÂä®Áâ©ÁöÑ ", { placeholderID: "vf_2", answer: "ÂÜÖËÑè" }, "„ÄÇ"] }, { parts: ["ËøôÂÆ∂ ", { placeholderID: "vf_3", answer: "Ê∏ÖÁúü" }, " È•≠È¶ÜÂÅöÁöÑÁæäËÇâ‰∏≤ÂæàÂ•ΩÂêÉ„ÄÇ"] }, { parts: ["ÊàëÂØπÊµ∑È≤ú ", { placeholderID: "vf_4", answer: "ËøáÊïè" }, "Ôºå‰∏ÄÂêÉË∫´‰∏äÂ∞±Áóí„ÄÇ"] }, { parts: ["ËøôÁßç ", { placeholderID: "vf_5a", answer: "È£üÁâ©" }, " Â§™ ", { placeholderID: "vf_5b", answer: "Ê≤πËÖª" }, " ‰∫ÜÔºåÂêÉÂ§ö‰∫ÜÂØπË∫´‰Ωì‰∏çÂ•Ω„ÄÇ"] }, { parts: ["‰∏∫‰∫ÜÂÅ•Â∫∑Ôºå‰ªñÁé∞Âú®ÂºÄÂßãÂêÉ ", { placeholderID: "vf_6", answer: "Á¥†È£ü" }, " ‰∫Ü„ÄÇ"] }, { parts: ["Â§öÂêÉ ", { placeholderID: "vf_7", answer: "Ëî¨Ëèú" }, " ÂØπË∫´‰ΩìÂ•ΩÔºåÂèØ‰ª•Ë°•ÂÖÖÁª¥ÁîüÁ¥†„ÄÇ"] }, { parts: ["ÈïøÊúü‰∏çÂêÉËÇâÂèØËÉΩ‰ºö ", { placeholderID: "vf_8a", answer: "ÂØºËá¥" }, " ", { placeholderID: "vf_8b", answer: "Ëê•ÂÖª" }, " ‰∏çË∂≥„ÄÇ"] }, { parts: ["ÊàëÂ¶àÂ¶à‰∏çÂñúÊ¨¢ ", { placeholderID: "vf_9", answer: "È¶ôËèú" }, " ÁöÑÂë≥ÈÅìÔºåÊâÄ‰ª•Êàë‰ª¨ÂÆ∂ÂÅöËèú‰ªéÊù•‰∏çÊîæ„ÄÇ"] }, { parts: ["Ëøô‰ªΩÂ•óÈ§ê ", { placeholderID: "vf_10", answer: "ÂåÖÊã¨" }, " ‰∏Ä‰ªΩ‰∏ªÈ£ü„ÄÅ‰∏Ä‰ªΩÊ±§Âíå‰∏ÄÊùØÈ•ÆÊñô„ÄÇ"] } ] };
        const sentenceCompletionData = [ { id: "sc_1", starter: "ÊàëÂèó‰∏ç‰∫Ü ", exampleSuffix: " ÁöÑÂë≥ÈÅì„ÄÇ (V√≠ d·ª•: Ëá≠Ë±ÜËÖê)" }, { id: "sc_2", starter: "Êó•Êú¨È•ÆÈ£üÊ∏ÖÊ∑°ÔºåÊâÄ‰ª•Âë≥ÈÅìÊØîËæÉÈáçÁöÑÈ£üÁâ©‰∏çÂ§™ÂèóÊ¨¢ËøéÔºå", exampleSuffix: " Âä®Áâ©ÁöÑÂÜÖËÑè„ÄÇ" }, { id: "sc_3", starter: "ÊàëÂØπ ", exampleSuffix: " ËøáÊïèÔºåÊâÄ‰ª•‰∏ÄÁÇπÂÑøÈÉΩ‰∏çËÉΩÂêÉ„ÄÇ (V√≠ d·ª•: Ëä±Áîü)" }, { id: "sc_4", starter: "Áî±‰∫é ", exampleSuffix: "ÔºåÊâÄ‰ª•ÊàëÂÜ≥ÂÆö‰ªäÂ§©Âú®ÂÆ∂‰ºëÊÅØ„ÄÇ (N√™u l√Ω do)" }, { id: "sc_5", starter: "‰ªñ‰∏ç‰ªÖÂ≠¶‰π†Â•ΩÔºå", exampleSuffix: " ËøòÂæàÂñúÊ¨¢Â∏ÆÂä©ÂêåÂ≠¶„ÄÇ" }, { id: "sc_6", starter: "ÊàëËßâÂæóÂ≠¶Â•ΩÊ±âËØ≠ÊúÄÂÖ≥ÈîÆÁöÑÊòØ ", exampleSuffix: "„ÄÇ" } ];
        const readingCompData = { passage: "(Êñ∞Â≠¶Êúü,ÂÖ®Áè≠Ë¶ÅËÅöÈ§ê,Â§ßÂÆ∂Ê≠£Âú®ÂïÜÈáèÂéªÂêÉ‰ªÄ‰πà„ÄÇ)\nÂº†Â∞èËñá: ÂêåÂ≠¶‰ª¨,Âë®‰∫î‰∏ãËØæÂêéÊàë‰ª¨‰∏ÄËµ∑ÂéªÂêÉ‰∏™È•≠ÊÄé‰πàÊ†∑?\nÊú¥Êô∫ÊÖß: Â•ΩÂïä,‰Ω†‰ª¨ÊÉ≥ÂêÉ‰ªÄ‰πà?\nÂ±±‰∏ãÂíå‰πü: ÂéªÂêÉÂõõÂ∑ùÁÅ´ÈîÖÂêß!Êàë‰∏ÄÁõ¥ÈÉΩÊÉ≥ËØïËØïÂ∑ùËèú„ÄÇ\nÊú¥Êô∫ÊÖß: ÂõõÂ∑ùÁÅ´ÈîÖ?ÊàëÂíåÊúãÂèãÂêÉËøá‰∏ÄÊ¨°,Ëæ£ÂæóÊàëÁõ¥ÊµÅÁúºÊ≥™„ÄÇÊàëÂèó‰∏ç‰∫Ü‰∏≠ÂõΩÁöÑËæ£Ê§í,‰πü‰∏çÂ§™ÂñúÊ¨¢ÁæäËÇâ„ÄÇ\nÂÜØÂ∞öÂæ∑: ÈÇ£Âí±‰ª¨Êç¢‰∏™È•≠È¶Ü„ÄÇÂ±±‰∏ã,Êó•Êú¨‰∫∫ÈÉΩ‰∏çÂêÉÁæäËÇâÂêó?\nÂ±±‰∏ãÂíå‰πü: Â§ßÈÉ®ÂàÜÊó•Êú¨‰∫∫ÈÉΩ‰∏çÂ§™ÂñúÊ¨¢ÁæäËÇâ„ÄÇÊó•Êú¨È•ÆÈ£üÊ∏ÖÊ∑°,ÊâÄ‰ª•Âë≥ÈÅìÊØîËæÉÈáçÁöÑÈ£üÁâ©‰∏çÂ§™ÂèóÊ¨¢Ëøé,ÂåÖÊã¨Âä®Áâ©ÁöÑÂÜÖËÑè„ÄÇ\nÂº†Â∞èËñá: ÊàëËßâÂæóÊúÄÂ•ΩÊâæ‰∏Ä‰∏™Ê∏ÖÁúüÈ•≠È¶Ü,Êñ∞Èò≥ÊòØÁ©ÜÊñØÊûó„ÄÇ\nÈôàÊñ∞Èò≥: Ë∞¢Ë∞¢Â∞èËñá!Êàë‰∏çÂêÉÈùûÊ∏ÖÁúüÁöÑËÇâÈ£ü„ÄÇ\nÂÜØÂ∞öÂæ∑: ÈÇ£Êàë‰ª¨ÂéªÂêÉ‰ªÄ‰πà?Â∞èËñá,‰Ω†Áü•ÈÅìÂì™ÂÑøÊúâÂ•ΩÂêÉÁöÑÂêó?\nÂº†Â∞èËñá: ÊàëÊÉ≥ÊÉ≥„ÄÇÂ∞öÂæ∑„ÄÅÊô∫ÊÖß,‰Ω†‰ª¨‰ø©Êúâ‰ªÄ‰πà‰∏çÂêÉÁöÑÂêó?ÂØπ‰ªÄ‰πàÈ£üÁâ©ËøáÊïè?\nÂÜØÂ∞öÂæ∑: ËøáÊïèÂÄíÊ≤°Êúâ,‰ΩÜÊòØÊàë‰πü‰∏çÂñúÊ¨¢ÂêÉÂÜÖËÑè„ÄÅÈ∏°Áà™Â≠ê‰πãÁ±ªÁöÑ„ÄÇÂÜÖËÑèÊúâÁßçÂ•áÊÄ™ÁöÑÂë≥ÈÅì,È∏°Áà™Â≠êÁúãËµ∑Êù•ÂÉè‰∫∫ÁöÑÊâã„ÄÇÂØπÊàëÊù•ËØ¥Ëøô‰∫õÈÉΩÊòØ‚ÄúÈªëÊöóÊñôÁêÜ‚Äù„ÄÇ\nÊú¥Êô∫ÊÖß: Êàë‰∏çÊÉ≥ÂêÉÂø´È§êÁ≠âÂ§™Ê≤πËÖªÁöÑÈ£üÁâ©,‰∏çÂÅ•Â∫∑,ÊúÄÂÖ≥ÈîÆÁöÑÊòØÂêÉ‰∏ÄÂè£Â∞±ËÉñ„ÄÇ‰∏çËøáËøôÊ†∑‰∏ÄÊù•,‰πüÂ∞ë‰∫ÜÂæàÂ§öÂêÉÂø´È§êÁöÑÂø´‰πê„ÄÇ\nÂº†Â∞èËñá: ÂèàÂ•ΩÂêÉÂèàÂÅ•Â∫∑ÁöÑÁÉ§È±º?\nÂ±±‰∏ãÂíå‰πü„ÄÅÈôàÊñ∞Èò≥„ÄÅÂÜØÂ∞öÂæ∑„ÄÅÊú¥Êô∫ÊÖß: ÂêåÊÑè!\nÂº†Â∞èËñá: ÈÇ£Êàë‰ª¨ÂéªÂêÉÊ∏ÖÁúüÁÉ§È±ºÂêß,ÊúâËæ£ÁöÑ,‰πüÊúâ‰∏çËæ£ÁöÑ,ËøòÂèØ‰ª•Êîæ‰∫õËî¨Ëèú„ÄÇ", questions: [ { id: "rc_q1", text: "‰ªñ‰ª¨‰∏∫‰ªÄ‰πàÊ≤°ÂéªÂêÉÂõõÂ∑ùÁÅ´ÈîÖ? (ËØ∑Áî®‚ÄúÂèó‰∏ç‰∫Ü‚ÄùÂíå‚ÄúËæ£Ê§í‚ÄùÂõûÁ≠î)", keywords: ["Âèó‰∏ç‰∫Ü", "Ëæ£Ê§í"] }, { id: "rc_q2", text: "‰ªÄ‰πàÊ†∑ÁöÑÈ£üÁâ©Âú®Êó•Êú¨‰∏çÂ§™ÂèóÊ¨¢Ëøé? (ËØ∑Áî®‚ÄúÈ£üÁâ©‚Äù, ‚ÄúÂåÖÊã¨‚ÄùÂíå‚ÄúÂÜÖËÑè‚ÄùÂõûÁ≠î)", keywords: ["È£üÁâ©", "ÂåÖÊã¨", "ÂÜÖËÑè"] }, { id: "rc_q3", text: "Âº†Â∞èËñá‰∏∫‰ªÄ‰πàÂª∫ËÆÆÂéªÊ∏ÖÁúüÈ•≠È¶Ü? (ËØ∑Áî®‚ÄúÊ∏ÖÁúü‚Äù, ‚ÄúÁ©ÜÊñØÊûó‚ÄùÂíå‚ÄúËÇâÈ£ü‚ÄùÂõûÁ≠î)", keywords: ["Ê∏ÖÁúü", "Á©ÜÊñØÊûó", "ËÇâÈ£ü"] }, { id: "rc_q4", text: "ÂÜØÂ∞öÂæ∑‰∏çÂêÉ‰ªÄ‰πà? (ËØ∑Áî®‚ÄúÂÜÖËÑè‚Äù, ‚ÄúÈ∏°Áà™Â≠ê‚ÄùÂíå‚ÄúÈªëÊöóÊñôÁêÜ‚ÄùÂõûÁ≠î)", keywords: ["ÂÜÖËÑè", "È∏°Áà™Â≠ê", "ÈªëÊöóÊñôÁêÜ"] }, { id: "rc_q5", text: "Êú¥Êô∫ÊÖß‰∏çÊÉ≥ÂêÉ‰ªÄ‰πà?‰∏∫‰ªÄ‰πà? (ËØ∑Áî®‚ÄúÈ£üÁâ©‚ÄùÂíå‚ÄúÊ≤πËÖª‚ÄùÂõûÁ≠î)", keywords: ["È£üÁâ©", "Ê≤πËÖª"] }, { id: "rc_q6", text: "‰ªñ‰ª¨ÊúÄÂêéÂÜ≥ÂÆöÂéªÂêÉ‰ªÄ‰πà?‰∏∫‰ªÄ‰πà? (ËØ∑Áî®‚ÄúÁÉ§È±º‚ÄùÂíå‚ÄúËî¨Ëèú‚ÄùÂõûÁ≠î)", keywords: ["ÁÉ§È±º", "Ëî¨Ëèú"] } ] };
        const sentenceCreationWordsNew = [ { hanzi: 'Ëæ£Ê§í', pinyin: 'l√†jiƒÅo', meaning: '·ªõt / chilli pepper' }, { hanzi: 'ÂÜÖËÑè', pinyin: 'n√®iz√†ng', meaning: 'n·ªôi t·∫°ng / internal organs' }, { hanzi: 'Ê≤πËÖª', pinyin: 'y√≥un√¨', meaning: 'd·∫ßu m·ª°, ng·∫•y / oily' }, { hanzi: 'ËøáÊïè', pinyin: 'gu√≤m«ên', meaning: 'd·ªã ·ª©ng / be allergic to' }, { hanzi: 'Á¥†È£ü', pinyin: 's√πsh√≠', meaning: 'ƒë·ªì chay, ƒÉn chay / vegetarian meal' }, { hanzi: 'ÂØºËá¥', pinyin: 'd«éozh√¨', meaning: 'd·∫´n ƒë·∫øn / lead to' }, { hanzi: 'ÊãíÁªù', pinyin: 'j√πju√©', meaning: 't·ª´ ch·ªëi / refuse' }, { hanzi: 'Áñ≤Âä≥', pinyin: 'p√≠l√°o', meaning: 'm·ªát m·ªèi / tired' } ];
        const paragraphWritingData = { title: "ÊàëÁöÑÈ•ÆÈ£üÂÅèÂ•Ω (S·ªü th√≠ch ƒÉn u·ªëng c·ªßa t√¥i)", instructions: "H√£y vi·∫øt m·ªôt ƒëo·∫°n vƒÉn (kho·∫£ng 100-150 ch·ªØ) gi·ªõi thi·ªáu v·ªÅ m·ªôt lo·∫°i ƒë·ªì ƒÉn b·∫°n kh√¥ng ƒÉn/kh√¥ng th√≠ch. H√£y gi·∫£i th√≠ch l√Ω do v√† n√≥i v·ªÅ nh·ªØng ·∫£nh h∆∞·ªüng (t·ªët ho·∫∑c kh√¥ng t·ªët) c·ªßa th√≥i quen ƒÉn u·ªëng n√†y ƒë·ªëi v·ªõi b·∫°n.", structureHint: "C·∫•u tr√∫c g·ª£i √Ω (tham kh·∫£o trang 9  v√† trang 10 ):\nÊàë‰∏çÂñúÊ¨¢/Âèó‰∏ç‰∫Ü... (M√≥n kh√¥ng th√≠ch/kh√¥ng ch·ªãu ƒë∆∞·ª£c):‰æãÂ¶ÇÔºöÊàë‰∏çÂêÉ/‰∏çÂñúÊ¨¢/Âèó‰∏ç‰∫ÜÈ¶ôËèú„ÄÇ\nÂéüÂõ† (L√Ω do):Áî±‰∫é... (V√≠ d·ª•: Áî±‰∫éÂÆÉÁöÑÂë≥ÈÅìÂæàÂ•áÊÄ™...)\nÊàñËÄÖ: Âõ†‰∏∫... (V√≠ d·ª•: Âõ†‰∏∫ÊàëÂØπÂÆÉËøáÊïè„ÄÇ)\nÊúÄÂÖ≥ÈîÆÁöÑÊòØ... (V√≠ d·ª•: ÊúÄÂÖ≥ÈîÆÁöÑÊòØÔºåÂêÉ‰∫Ü‰ª•ÂêéÊàë‰ºö‰∏çËàíÊúç„ÄÇ)\nÂΩ±Âìç (·∫¢nh h∆∞·ªüng - c√≥ th·ªÉ l√† Â•ΩÂ§Ñ ho·∫∑c ÈóÆÈ¢ò):\nÂ•ΩÂ§Ñ (M·∫∑t t·ªët):ÊàëËÆ§‰∏∫‰∏çÂêÉ...ÊúâÂà©‰∫é... (V√≠ d·ª•: ÊàëËÆ§‰∏∫‰∏çÂêÉÊ≤πËÖªÁöÑÈ£üÁâ©ÊúâÂà©‰∫éÂÅ•Â∫∑„ÄÇ)\n‰∏çÂêÉ...ÁªôÊàëÂ∏¶Êù•ÂæàÂ§öÂ•ΩÂ§Ñ„ÄÇÈ¶ñÂÖà...ÔºåÂÖ∂Ê¨°...ÔºåÊõ¥ÈáçË¶ÅÁöÑÊòØ...\nÈóÆÈ¢ò (V·∫•n ƒë·ªÅ):‰∏çÂêÉ...ÁªôÊàëÂ∏¶Êù•ÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ (V√≠ d·ª•: ‰∏çÂêÉËæ£ÁªôÊàëÁÇπËèúÂ∏¶Êù•ÂæàÂ§öÈ∫ªÁÉ¶„ÄÇ)\n‰∏ç‰ªÖ...ÔºåËÄå‰∏î... (V√≠ d·ª•: ËøôÁßçÈ•ÆÈ£ü‰π†ÊÉØ‰∏ç‰ªÖËÆ©ÊàëÂæàÈöæÂíåÊúãÂèã‰∏ÄËµ∑ÂêÉÈ•≠ÔºåËÄå‰∏îÊúâÊó∂‰ºöÂØºËá¥Ëê•ÂÖª‰∏çË∂≥„ÄÇ)", vocabHint: "T·ª´ v·ª±ng c√≥ th·ªÉ s·ª≠ d·ª•ng (tham kh·∫£o trang 10 ):\nÊèèËø∞‰∏çÂêÉ‰ªÄ‰πà (M√¥ t·∫£ kh√¥ng ƒÉn g√¨): Ëæ£Ê§í, È£üÁâ©, ÂåÖÊã¨, ÂÜÖËÑè, ËÇâÈ£ü, È∏°Áà™Â≠ê, ÈªëÊöóÊñôÁêÜ, ÁÉ§È±º, Ëî¨Ëèú, ÊãíÁªù, È¶ôËèú, Âø´È§ê, ÂùöÊûú„ÄÇ\nËØ¥Êòé‰∏çÂêÉÁöÑÂéüÂõ† (Gi·∫£i th√≠ch l√Ω do kh√¥ng ƒÉn): Âèó‰∏ç‰∫Ü, Ê∏ÖÁúü, Á©ÜÊñØÊûó, ËøáÊïè, Ê≤πËÖª, Á¥†È£ü, ‰π≥Á≥ñ‰∏çËÄêÂèó, ÂÆÅÂèØ‚Ä¶‰πü‚Ä¶, ÂÜµ‰∏î„ÄÇ\nÂàÜÊûêËøôÁßçÈ•ÆÈ£üÂÅèÂ•ΩÂíå‰π†ÊÉØÂ∏¶Êù•ÁöÑÂ•ΩÂ§ÑÊàñÈóÆÈ¢ò (Ph√¢n t√≠ch l·ª£i √≠ch/v·∫•n ƒë·ªÅ): ÂØºËá¥, Ëê•ÂÖª‰∏çË∂≥, Ë∫´Êùê, ÂÖÖÊª°ÂäõÈáè, Áñ≤Âä≥, ‰∏•Èáç, ÈÄÇÂ∫¶„ÄÇ" };

        // ----- BI·∫æN TR·∫†NG TH√ÅI GAME -----
        let currentStage = 0; let gameStages = []; let totalQuestionsInGame = 0;
        let startTime; let timerInterval;
        let gameResults = { correct: 0, incorrect: 0, errors: [], totalTime: '00:00' };
        let playerName = "";
        let currentVocabMatchingPairs = []; let currentFillSentenceIndex = 0; let currentSentenceCompletionIndex = 0; let currentReadingQuestionIndex = 0; let currentSentenceCreationWordIndex = 0;
        let currentTargetWordForSC = null;

        // ----- GOOGLE FORM CONFIGURATION -----
        const GOOGLE_FORM_ACTION_URL = "https://docs.google.com/forms/d/e/1FAIpQLSeBAu4nmQQX6F3wMeoEzwgCH-JFKT8e1wJ3u-yp4KANey39Fw/formResponse";
        const STUDENT_NAME_ENTRY_ID = "entry.497915687"; const TOTAL_TIME_ENTRY_ID = "entry.1644850563"; const CORRECT_COUNT_ENTRY_ID = "entry.1575464331"; const INCORRECT_COUNT_ENTRY_ID = "entry.1038973429"; const ERRORS_LIST_ENTRY_ID = "entry.888446367";

        // ----- DOM ELEMENTS -----
        const getEl = (id) => document.getElementById(id);
        const timerEl = () => getEl('timer'); const instructionsEl = () => getEl('instructions'); const gameAreaEl = () => getEl('game-area'); const hintButtonEl = () => getEl('hint-button'); const hintTextEl = () => getEl('hint-text'); const feedbackSectionEl = () => getEl('feedback-section'); const feedbackTextEl = () => getEl('feedback-text'); const nextStageButtonEl = () => getEl('next-stage-button'); const summaryPageEl = () => getEl('summary-page'); const gameContainerEl = () => getEl('game-container'); const tooltipEl = () => getEl('tooltip');

        // ----- FUNCTIONS -----

        // --- AI Integration (Google Gemini Flash) ---
        async function callAI(prompt) {
            const currentFeedbackEl = feedbackTextEl(); const currentFeedbackSectionEl = feedbackSectionEl();
            let purpose = "Unknown";
            // C·∫≠p nh·∫≠t c√°ch x√°c ƒë·ªãnh purpose d·ª±a tr√™n t√™n h√†m c·ªßa stage hi·ªán t·∫°i
            const currentStageFunction = gameStages[currentStage -1];
            if (currentStageFunction) {
                 if (currentStageFunction.name.includes("SentenceCompletion") || currentStageFunction.name.includes("ReadingComp") || currentStageFunction.name.includes("SentenceCreation") || currentStageFunction.name.includes("ParagraphWriting")) {
                     purpose = "Check Answer";
                 }
            }
            if (prompt.includes("t·∫°o m·ªôt g·ª£i √Ω")) { // ∆Øu ti√™n ki·ªÉm tra prompt g·ª£i √Ω
                 purpose = "Generate Hint";
            }


            console.log(`--- G·ªçi AI (Gemini Flash) v·ªõi prompt (${purpose}) ---`); console.log(prompt);
            if (!currentFeedbackEl || !currentFeedbackSectionEl) { console.error("Feedback elements not found!"); return { isCorrect: false, explanation: "L·ªói giao di·ªán: Kh√¥ng t√¨m th·∫•y v√πng hi·ªÉn th·ªã ph·∫£n h·ªìi." }; }

            // Ch·ªâ hi·ªán loading n·∫øu kh√¥ng ph·∫£i ƒëang t·∫°o g·ª£i √Ω (v√¨ t·∫°o g·ª£i √Ω ƒë√£ c√≥ loading ri√™ng trong showHint)
            if (purpose !== 'Generate Hint') {
                currentFeedbackEl.textContent = "üß† AI ƒëang suy nghƒ©..."; // ƒê√É S·ª¨A
                currentFeedbackSectionEl.className = 'info';
                currentFeedbackSectionEl.style.display = 'block';
            }

            const apiKey = 'AIzaSyBvdzFJAA8xSTMZ17nse19boON9zGopUyU';
            const modelName = 'gemini-1.5-flash-latest';
            const apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
            const generationConfig = { temperature: 0.5, maxOutputTokens: 400 };
            const safetySettings = [ { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }, ];

            try {
                const response = await fetch(apiEndpoint, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ contents: [{ parts: [{ "text": prompt }] }], generationConfig: generationConfig, safetySettings: safetySettings }), });
                if (!response.ok) { let errorData; try { errorData = await response.json(); console.error("L·ªói API (JSON):", errorData); } catch (e) { const errorText = await response.text(); console.error("L·ªói API (Text):", errorText); errorData = { error: { message: errorText || 'Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c l·ªói' } }; } const errorMessage = `L·ªói API ${response.status}: ${errorData?.error?.message || response.statusText || 'Kh√¥ng r√µ chi ti·∫øt'}.`; throw new Error(errorMessage); }
                const data = await response.json(); console.log(`Ph·∫£n h·ªìi t·ª´ ${modelName}:`, data);
                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content || !data.candidates[0].content.parts || data.candidates[0].content.parts.length === 0) { const blockReason = data?.promptFeedback?.blockReason || "Kh√¥ng c√≥ ·ª©ng vi√™n tr·∫£ v·ªÅ"; const safetyRatings = data?.promptFeedback?.safetyRatings; console.error("AI Response Blocked/Empty:", blockReason, safetyRatings); throw new Error(`Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n ho·∫∑c tr·ªëng. L√Ω do: ${blockReason}.`); }
                const aiTextResponse = data?.candidates?.[0]?.content?.parts?.[0]?.text || "AI kh√¥ng ƒë∆∞a ra ph·∫£n h·ªìi vƒÉn b·∫£n."; console.log("N·ªôi dung AI tr·∫£ v·ªÅ:", aiTextResponse);

                if (purpose === 'Generate Hint') { return { explanation: aiTextResponse }; }
                else {
                    let lowerResponse = aiTextResponse.toLowerCase(); let isCorrect = false;
                    const currentStageFuncName = currentStageFunction ? currentStageFunction.name : "";

                    if ((currentStageFuncName.includes("SentenceCreation") || currentStageFuncName.includes("SentenceCompletion") || currentStageFuncName.includes("ReadingComp")) && (lowerResponse.startsWith("ƒë√°nh gi√°: ƒë√∫ng") || lowerResponse.startsWith("ƒë√°nh gi√° t·ªïng th·ªÉ: ƒë√∫ng"))) {
                        isCorrect = true;
                    } else if (currentStageFuncName.includes("ParagraphWriting") && !lowerResponse.includes("c·∫ßn c·∫£i thi·ªán nhi·ªÅu") && (lowerResponse.includes("t·ªët") || lowerResponse.includes("kh√°"))) { // Cho b√†i vi·∫øt ƒëo·∫°n
                        isCorrect = true;
                    }

                    let explanation = aiTextResponse;
                    if (isCorrect && explanation.length > 150 && (explanation.includes("ph√¢n t√≠ch") || explanation.includes("gi·∫£i th√≠ch"))) { explanation = (currentStageFuncName.includes("SentenceCreation") || currentStageFuncName.includes("SentenceCompletion") ? "ƒê√°nh gi√°: ƒê√∫ng. C√¢u t·ªët." : "ƒê√°nh gi√°: ƒê√∫ng. Ph√π h·ª£p."); }
                    else if (isCorrect && explanation.length > 150) { explanation = explanation.split('.')[0] + '.'; if(!explanation.toLowerCase().startsWith("ƒë√°nh gi√°")) { explanation = (currentStageFuncName.includes("SentenceCreation") || currentStageFuncName.includes("SentenceCompletion") ? "ƒê√°nh gi√°: ƒê√∫ng. C√¢u t·ªët." : "ƒê√°nh gi√°: ƒê√∫ng. Ph√π h·ª£p.");} }
                    return { isCorrect, explanation };
                }
            } catch (error) {
                console.error(`L·ªói khi g·ªçi ${modelName} API:`, error);
                if (purpose === 'Generate Hint') { hintTextEl().textContent = "L·ªói: Kh√¥ng th·ªÉ t·∫°o g·ª£i √Ω t·ª´ AI."; hintButtonEl().disabled = false; return { explanation: "L·ªói t·∫°o g·ª£i √Ω." }; }
                else { currentFeedbackEl.textContent = error.message; currentFeedbackSectionEl.className = 'incorrect'; currentFeedbackSectionEl.style.display = 'block'; throw error; }
            }
        }

        // --- Timer Functions ---
        function startTimer() { startTime = Date.now(); if(timerInterval) clearInterval(timerInterval); timerInterval = setInterval(updateTimer, 1000); updateTimer(); }
        function updateTimer() { const currentTimerEl = timerEl(); if (!currentTimerEl) { if (timerInterval) clearInterval(timerInterval); return; } const elapsedTime = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0'); const seconds = (elapsedTime % 60).toString().padStart(2, '0'); currentTimerEl.textContent = `${minutes}:${seconds}`; gameResults.totalTime = `${minutes}:${seconds}`; }
        function stopTimer() { if(timerInterval) clearInterval(timerInterval); timerInterval = null; }

        // --- UI and Feedback ---
        function setInstructions(htmlContentWithIcon) { // S·ª≠a ƒë·ªÉ nh·∫≠n HTML c√≥ icon
            const currentInstructionsEl = instructionsEl();
            if (currentInstructionsEl) {
                currentInstructionsEl.innerHTML = `<p>${htmlContentWithIcon}</p>`;
            }
        }
        function showFeedback(isCorrect, message) { const currentFeedbackSectionEl = feedbackSectionEl(); const currentFeedbackTextEl = feedbackTextEl(); if (!currentFeedbackSectionEl || !currentFeedbackTextEl) return; currentFeedbackTextEl.textContent = message; currentFeedbackSectionEl.className = isCorrect ? 'correct' : 'incorrect'; currentFeedbackSectionEl.style.display = 'block'; }
        function recordResult(isCorrect, stageName, input, issue) { if (isCorrect) { gameResults.correct++; } else { gameResults.incorrect++; gameResults.errors.push({ stage: stageName, input: input || 'N/A', issue }); } console.log("Game Results Updated:", JSON.stringify(gameResults)); }
        function clearFeedback() { const currentFeedbackSectionEl = feedbackSectionEl(); const currentFeedbackTextEl = feedbackTextEl(); if (!currentFeedbackSectionEl || !currentFeedbackTextEl) return; currentFeedbackTextEl.textContent = ''; currentFeedbackSectionEl.style.display = 'none'; currentFeedbackSectionEl.className = ''; }
        async function showHint() { /* Gi·ªØ nguy√™n logic AI Hint */ }
        function clearHint() { const currentHintTextEl = hintTextEl(); if (currentHintTextEl) currentHintTextEl.textContent = ''; }
        function showTooltip(element, key) { /* Gi·ªØ nguy√™n */ }
        function hideTooltip() { /* Gi·ªØ nguy√™n */ }
        function hideTooltipOnClickOutside(event) { /* Gi·ªØ nguy√™n */ }
        async function submitResultsToGoogleForm() { /* Gi·ªØ nguy√™n */ }


        // ----- QU·∫¢N L√ù M√ÄN CH∆†I -----
        function loadNextStage() {
            currentStage++;
            clearFeedback();
            clearHint();
            const nextBtn = nextStageButtonEl();
            if(nextBtn) nextBtn.classList.add('hidden');

            if (currentStage <= gameStages.length) {
                const stageLoaderFunction = gameStages[currentStage - 1];
                console.log(`Loading stage ${currentStage}: ${stageLoaderFunction.name}`);
                stageLoaderFunction();
                hintButtonEl()?.classList.remove('hidden');
            } else {
                console.log("All stages completed. Showing summary.");
                showSummary();
                hintButtonEl()?.classList.add('hidden');
            }
        }
        // ----- C√ÅC H√ÄM LOAD M√ÄN CH∆†I -----
        function loadVocabMatchingStage() {
            setInstructions("ü§ù M√†n 1.1: N·ªëi T·ª´. K√©o t·ª´ ti·∫øng Trung v√†o √¥ nghƒ©a t∆∞∆°ng ·ª©ng."); // Th√™m icon
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');
            const words = vocabMatchingData.map(item => ({ id: item.id, text: `${item.hanzi} (${item.pinyin})`}));
            const meanings = vocabMatchingData.map(item => ({ id: item.id, text: item.meaning }));
            shuffleArray(words); shuffleArray(meanings);
            let wordHTML = words.map(w => `<div class="draggable-word" draggable="true" data-id="${w.id}">${w.text}</div>`).join('');
            let meaningHTML = meanings.map(m => `<div class="meaning-target" data-target-id="${m.id}">${m.text}</div>`).join('');
            gameArea.innerHTML = ` <h3 class="stage-title">B√†i 1.1: N·ªëi T·ª´ V·ªõi Nghƒ©a</h3> <div id="vocab-matching-area"> <div class="vocab-list-column" id="word-source-column">${wordHTML}</div> <div class="meaning-list-column" id="meaning-target-column">${meaningHTML}</div> </div> <button id="check-matching">Ki·ªÉm Tra N·ªëi T·ª´</button> `;
            addDragDropListeners();
            getEl('check-matching').addEventListener('click', checkVocabMatching);
        }
        function addDragDropListeners() { const draggables = document.querySelectorAll('.draggable-word'); const targets = document.querySelectorAll('.meaning-target'); let draggedItem = null; draggables.forEach(draggable => { draggable.addEventListener('dragstart', (e) => { draggedItem = draggable; setTimeout(() => draggable.style.opacity = '0.5', 0); }); draggable.addEventListener('dragend', () => { setTimeout(() => { draggable.style.opacity = '1'; if (draggedItem && draggedItem.parentElement.id !== 'meaning-target-column') { const sourceColumn = getEl('word-source-column'); if (sourceColumn && !Array.from(sourceColumn.children).includes(draggedItem)) sourceColumn.appendChild(draggedItem); } draggedItem = null; }, 0); }); }); targets.forEach(target => { target.addEventListener('dragover', (e) => { e.preventDefault(); target.classList.add('over'); }); target.addEventListener('dragleave', () => { target.classList.remove('over'); }); target.addEventListener('drop', (e) => { e.preventDefault(); target.classList.remove('over'); if (draggedItem && !target.querySelector('.draggable-word')) { target.appendChild(draggedItem); draggedItem = null; } else if (draggedItem) { const sourceColumn = getEl('word-source-column'); if (sourceColumn) sourceColumn.appendChild(draggedItem); draggedItem = null; } }); }); }
        function checkVocabMatching() { let correctMatches = 0; const targets = document.querySelectorAll('.meaning-target'); targets.forEach(target => { const droppedWordEl = target.querySelector('.draggable-word'); if (droppedWordEl) { const wordId = droppedWordEl.dataset.id; const targetId = target.dataset.targetId; if (wordId === targetId) { correctMatches++; target.classList.add('dropped-correct'); target.classList.remove('dropped-incorrect'); droppedWordEl.draggable = false; } else { target.classList.add('dropped-incorrect'); target.classList.remove('dropped-correct'); } } else { target.classList.remove('dropped-correct', 'dropped-incorrect');} }); if(gameStages[currentStage-1].name === "loadVocabMatchingStage" && !getEl('check-matching').dataset.counted) { totalQuestionsInGame += vocabMatchingData.length; getEl('check-matching').dataset.counted = 'true'; } recordResult(correctMatches === vocabMatchingData.length, "N·ªëi t·ª´ B√†i 1.1", `ƒê√∫ng ${correctMatches}/${vocabMatchingData.length}`, correctMatches === vocabMatchingData.length ? "" : "M·ªôt s·ªë c·∫∑p n·ªëi ch∆∞a ƒë√∫ng."); showFeedback(correctMatches === vocabMatchingData.length, `B·∫°n ƒë√£ n·ªëi ƒë√∫ng ${correctMatches} / ${vocabMatchingData.length} c·∫∑p.`); if (correctMatches === vocabMatchingData.length) { nextStageButtonEl()?.classList.remove('hidden'); getEl('check-matching').disabled = true; } else { getEl('check-matching').disabled = false; } }
        function loadVocabFillStage() { setInstructions("‚úçÔ∏è M√†n 1.2: Ch·ªçn T·ª´. Ch·ªçn t·ª´ th√≠ch h·ª£p t·ª´ danh s√°ch ƒë·ªÉ ƒëi·ªÅn v√†o ch·ªó tr·ªëng."); const gameArea = gameAreaEl(); hintButtonEl()?.classList.add('hidden'); currentFillSentenceIndex = 0; let sentencesHTML = vocabFillData.sentences.map((sentenceData, index) => { let sentenceHTML = `<div class="fill-sentence" id="vf_sentence_${index + 1}">`; sentenceData.parts.forEach(part => { if (typeof part === 'string') { sentenceHTML += `<span>${part}</span>`; } else { sentenceHTML += `<select id="${part.placeholderID}">`; sentenceHTML += `<option value="">---Ch·ªçn---</option>`; vocabFillData.options.forEach(opt => { sentenceHTML += `<option value="${opt}">${opt}</option>`; }); sentenceHTML += `</select>`; } }); sentenceHTML += `</div>`; return sentenceHTML; }).join(''); gameArea.innerHTML = ` <h3 class="stage-title">B√†i 1.2: Ch·ªçn T·ª´ Th√≠ch H·ª£p</h3> <p><strong>T·ª´ ƒë·ªÉ ch·ªçn:</strong> ${vocabFillData.options.join(', ')}</p> ${sentencesHTML} <button id="check-vocab-fill">Ki·ªÉm Tra ƒêi·ªÅn T·ª´</button> `; getEl('check-vocab-fill').addEventListener('click', checkVocabFill); }
        function checkVocabFill() { let correctCount = 0; let totalBlanksInThisStage = 0; const feedbackMessages = []; vocabFillData.sentences.forEach((sentenceData, sentenceIndex) => { sentenceData.parts.forEach(part => { if (typeof part !== 'string') { totalBlanksInThisStage++; const selectedValue = getEl(part.placeholderID).value; if (selectedValue === part.answer) { correctCount++; getEl(part.placeholderID).style.borderColor = 'green'; } else { getEl(part.placeholderID).style.borderColor = 'red'; feedbackMessages.push(`C√¢u ${sentenceIndex + 1}, ch·ªó tr·ªëng "${part.answer}" ch·ªçn sai.`); } } }); }); if(gameStages[currentStage-1].name === "loadVocabFillStage" && !getEl('check-vocab-fill').dataset.counted) { totalQuestionsInGame += totalBlanksInThisStage; getEl('check-vocab-fill').dataset.counted = 'true';} recordResult(correctCount === totalBlanksInThisStage, "ƒêi·ªÅn t·ª´ B√†i 1.2", `ƒê√∫ng ${correctCount}/${totalBlanksInThisStage}`, correctCount === totalBlanksInThisStage ? "" : feedbackMessages.join(" ")); showFeedback(correctCount === totalBlanksInThisStage, `B·∫°n ƒë√£ ƒëi·ªÅn ƒë√∫ng ${correctCount} / ${totalBlanksInThisStage} ch·ªó tr·ªëng. ${correctCount !== totalBlanksInThisStage ? 'H√£y xem l·∫°i c√°c ch·ªó b√¥i ƒë·ªè.' : ''}`); if (correctCount === totalBlanksInThisStage) { nextStageButtonEl()?.classList.remove('hidden'); getEl('check-vocab-fill').disabled = true; } else { getEl('check-vocab-fill').disabled = false;} }
        function loadSentenceCompletionStage() { setInstructions("üìù M√†n 2.1: Ho√†n Th√†nh C√¢u. S·ª≠ d·ª•ng c√°c c·∫•u tr√∫c ƒë√£ h·ªçc ƒë·ªÉ vi·∫øt ti·∫øp c√¢u."); const gameArea = gameAreaEl(); hintButtonEl()?.classList.add('hidden'); currentSentenceCompletionIndex = 0; if(gameStages[currentStage-1].name === "loadSentenceCompletionStage" && !gameArea.dataset.questionsCounted) { totalQuestionsInGame += sentenceCompletionData.length; gameArea.dataset.questionsCounted = 'true';} let itemsHTML = sentenceCompletionData.map((item, index) => ` <div class="sentence-completion-item"> <label for="sc_input_${item.id}">${index + 1}. ${item.starter} <input type="text" id="sc_input_${item.id}" placeholder="Vi·∫øt ti·∫øp v√†o ƒë√¢y..." style="width:60%; padding:5px; font-size:0.9em;"> ${item.exampleSuffix || ''}</label> </div> `).join(''); gameArea.innerHTML = ` <h3 class="stage-title">B√†i 2.1: Ho√†n Th√†nh C√¢u</h3> ${itemsHTML} <button id="check-sentence-completion">Ki·ªÉm Tra Ho√†n Th√†nh C√¢u</button> `; getEl('check-sentence-completion').addEventListener('click', checkAllSentenceCompletions); }
        async function checkAllSentenceCompletions() { const submitButton = getEl('check-sentence-completion'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback(); let allCorrectThisCheck = true; let stageFeedback = []; for (let i = 0; i < sentenceCompletionData.length; i++) { const item = sentenceCompletionData[i]; const userInputEl = getEl(`sc_input_${item.id}`); const userInput = userInputEl.value.trim(); const fullSentenceAttempt = item.starter + userInput; if (!userInput) { userInputEl.style.borderColor = 'red'; allCorrectThisCheck = false; recordResult(false, `Ho√†n th√†nh c√¢u ${i+1}`, "Ch∆∞a nh·∫≠p", "Ch∆∞a ho√†n th√†nh c√¢u."); stageFeedback.push(`C√¢u ${i+1}: B·∫°n ch∆∞a ho√†n th√†nh c√¢u.`); } else { const prompt = `L√† m·ªôt gi√°o vi√™n ti·∫øng Trung, h√£y ƒë√°nh gi√° ph·∫ßn ho√†n th√†nh c√¢u sau c·ªßa h·ªçc sinh: "${userInput}" cho ph·∫ßn ƒë·∫ßu c√¢u: "${item.starter}". C√¢u ho√†n ch·ªânh "${fullSentenceAttempt}" c√≥ ƒë√∫ng ng·ªØ ph√°p, logic v√† t·ª± nhi√™n kh√¥ng? Tr·∫£ l·ªùi b·∫Øt ƒë·∫ßu b·∫±ng "ƒê√°nh gi√°: [ƒê√∫ng/Sai]". N·∫øu Sai, ch·ªâ ra l·ªói v√† g·ª£i √Ω s·ª≠a NG·∫ÆN G·ªåN. N·∫øu ƒê√∫ng, ch·ªâ c·∫ßn ghi "ƒê√°nh gi√°: ƒê√∫ng. C√¢u t·ªët."`; try { const aiResult = await callAI(prompt); recordResult(aiResult.isCorrect, `Ho√†n th√†nh c√¢u ${i+1}`, fullSentenceAttempt, aiResult.isCorrect ? "" : aiResult.explanation); if (!aiResult.isCorrect) { allCorrectThisCheck = false; userInputEl.style.borderColor = 'red'; } else { userInputEl.style.borderColor = 'green'; } stageFeedback.push(`C√¢u ${i+1}: ${aiResult.explanation}`); } catch (error) { allCorrectThisCheck = false; recordResult(false, `Ho√†n th√†nh c√¢u ${i+1}`, fullSentenceAttempt, `L·ªói API: ${error.message}`); stageFeedback.push(`C√¢u ${i+1}: L·ªói khi ki·ªÉm tra v·ªõi AI.`); userInputEl.style.borderColor = 'orange'; } } } showFeedback(allCorrectThisCheck, stageFeedback.join("\n\n")); submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra Ho√†n Th√†nh C√¢u"; if (allCorrectThisCheck) { nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true; } }
        // --- C·∫¨P NH·∫¨T H√ÄM loadReadingCompStage ---
        function loadReadingCompStage() {
            setInstructions("üìñ M√†n 3.1: ƒê·ªçc Hi·ªÉu. ƒê·ªçc ƒëo·∫°n vƒÉn v√† tr·∫£ l·ªùi c√¢u h·ªèi."); // Th√™m icon
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden'); // Ho·∫∑c k√≠ch ho·∫°t AI hint sau
            currentReadingQuestionIndex = 0;
            if(gameStages.find(stage => stage === loadReadingCompStage) && !gameArea.dataset.questionsCounted) {
                totalQuestionsInGame += readingCompData.questions.length;
                gameArea.dataset.questionsCounted = 'true';
            }

            const passage = readingCompData.passage;
            const lines = passage.split('\n');
            let formattedPassageHTML = '';
            // ƒê·ªãnh nghƒ©a m√†u cho t·ª´ng nh√¢n v·∫≠t
            const characterColors = {
                'Âº†Â∞èËñá': '#007bff', // Xanh d∆∞∆°ng
                'Êú¥Êô∫ÊÖß': '#28a745', // Xanh l√°
                'Â±±‰∏ãÂíå‰πü': '#fd7e14', // Cam
                'ÂÜØÂ∞öÂæ∑': '#6f42c1', // T√≠m
                'ÈôàÊñ∞Èò≥': '#d63384', // H·ªìng
                // Cho c·ª•m "Â±±‰∏ãÂíå‰πü„ÄÅÈôàÊñ∞Èò≥„ÄÅÂÜØÂ∞öÂæ∑„ÄÅÊú¥Êô∫ÊÖß"
                'Â±±‰∏ãÂíå‰πü„ÄÅÈôàÊñ∞Èò≥„ÄÅÂÜØÂ∞öÂæ∑„ÄÅÊú¥Êô∫ÊÖß': '#6610f2' // M·ªôt m√†u t√≠m kh√°c
            };

            lines.forEach(line => {
                if (line.trim() === '') {
                    // formattedPassageHTML += '<br>'; // Gi·ªØ l·∫°i d√≤ng tr·ªëng n·∫øu c√≥ √Ω nghƒ©a ph√¢n c√°ch
                    return; // B·ªè qua d√≤ng tr·ªëng ho√†n to√†n
                }
                let speaker = null;
                let speech = line;
                let speakerClass = 'speaker-default'; // M√†u m·∫∑c ƒë·ªãnh

                // C·ªë g·∫Øng t√¨m t√™n nh√¢n v·∫≠t ·ªü ƒë·∫ßu d√≤ng
                for (const charName in characterColors) {
                    if (line.startsWith(charName + ":")) {
                        speaker = charName;
                        speech = line.substring(charName.length + 1).trim(); // +1 cho d·∫•u hai ch·∫•m, +1 n·ªØa cho kho·∫£ng tr·∫Øng
                        speakerClass = `speaker-${charName.toLowerCase().replace(/[^a-z0-9]/g, '')}`; // T·∫°o class CSS (n·∫øu d√πng class)
                        break;
                    }
                }

                if (speaker) {
                    // S·ª≠ d·ª•ng m√†u ƒë√£ ƒë·ªãnh nghƒ©a, n·∫øu kh√¥ng c√≥ th√¨ d√πng m√†u m·∫∑c ƒë·ªãnh
                    const color = characterColors[speaker] || '#343a40';
                    formattedPassageHTML += `<p class="speaker-line" style="margin-bottom: 0.8em;"><strong style="color: ${color};">${speaker}:</strong> <span style="color: ${color};">${speech}</span></p>`;
                } else if (line.startsWith('(') && line.endsWith(')')) {
                    formattedPassageHTML += `<p class="reading-narrative" style="margin-bottom: 0.8em;">${line}</p>`;
                } else {
                     // C√°c d√≤ng kh√¥ng c√≥ ng∆∞·ªùi n√≥i c·ª• th·ªÉ, ho·∫∑c d√≤ng "ƒë·ªìng √Ω" c·ªßa nhi·ªÅu ng∆∞·ªùi
                     // Ki·ªÉm tra tr∆∞·ªùng h·ª£p nhi·ªÅu ng∆∞·ªùi n√≥i
                     const multiSpeakerKey = 'Â±±‰∏ãÂíå‰πü„ÄÅÈôàÊñ∞Èò≥„ÄÅÂÜØÂ∞öÂæ∑„ÄÅÊú¥Êô∫ÊÖß';
                     if (line.startsWith(multiSpeakerKey + ":")) {
                         speaker = multiSpeakerKey;
                         speech = line.substring(multiSpeakerKey.length + 1).trim();
                         const color = characterColors[speaker] || '#343a40';
                         formattedPassageHTML += `<p class="speaker-line" style="margin-bottom: 0.8em;"><strong style="color: ${color};">${speaker}:</strong> <span style="color: ${color};">${speech}</span></p>`;
                     } else {
                        formattedPassageHTML += `<p style="margin-bottom: 0.8em;">${line}</p>`; // D√≤ng b√¨nh th∆∞·ªùng
                     }
                }
            });


            let questionsHTML = readingCompData.questions.map((q, index) => `
                <div class="reading-question">
                    <label for="rc_input_${q.id}">${index + 1}. ${q.text}</label>
                    <textarea id="rc_input_${q.id}" rows="3"></textarea>
                </div>
            `).join('');

            gameArea.innerHTML = `
                <h3 class="stage-title">B√†i 3.1: ƒê·ªçc Hi·ªÉu</h3>
                <div id="reading-passage">${formattedPassageHTML}</div>
                ${questionsHTML}
                <button id="check-reading-comp">Ki·ªÉm Tra ƒê·ªçc Hi·ªÉu</button>
            `;
            getEl('check-reading-comp').addEventListener('click', checkAllReadingComp);
        }
        async function checkAllReadingComp() { const submitButton = getEl('check-reading-comp'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback(); let allCorrectThisCheck = true; let stageFeedback = []; for (let i = 0; i < readingCompData.questions.length; i++) { const q = readingCompData.questions[i]; const userInputEl = getEl(`rc_input_${q.id}`); const userAnswer = userInputEl.value.trim(); if (!userAnswer) { userInputEl.style.borderColor = 'red'; allCorrectThisCheck = false; recordResult(false, `ƒê·ªçc hi·ªÉu Q${i+1}`, "Ch∆∞a nh·∫≠p", "Ch∆∞a tr·∫£ l·ªùi c√¢u h·ªèi."); stageFeedback.push(`C√¢u ${i+1}: B·∫°n ch∆∞a tr·∫£ l·ªùi c√¢u h·ªèi.`); } else { const prompt = `D·ª±a v√†o ƒëo·∫°n vƒÉn sau: "${readingCompData.passage}".\nC√¢u h·ªèi l√†: "${q.text}".\nH·ªçc sinh tr·∫£ l·ªùi: "${userAnswer}".\nC√¢u tr·∫£ l·ªùi c√≥ ƒë√∫ng v√† d·ª±a tr√™n n·ªôi dung ƒëo·∫°n vƒÉn kh√¥ng? C√≥ s·ª≠ d·ª•ng ƒë√∫ng c√°c t·ª´ kh√≥a ƒë∆∞·ª£c y√™u c·∫ßu (${q.keywords.join(', ')}) kh√¥ng (n·∫øu c√°c t·ª´ kh√≥a ƒë√≥ ph√π h·ª£p)? ƒê√°nh gi√° b·∫Øt ƒë·∫ßu b·∫±ng "ƒê√°nh gi√°: [ƒê√∫ng/Sai]" v√† gi·∫£i th√≠ch NG·∫ÆN G·ªåN n·∫øu sai.`; try { const aiResult = await callAI(prompt); recordResult(aiResult.isCorrect, `ƒê·ªçc hi·ªÉu Q${i+1}`, userAnswer, aiResult.isCorrect ? "" : aiResult.explanation); if (!aiResult.isCorrect) { allCorrectThisCheck = false; userInputEl.style.borderColor = 'red'; } else { userInputEl.style.borderColor = 'green'; } stageFeedback.push(`C√¢u ${i+1}: ${aiResult.explanation}`); } catch (error) { allCorrectThisCheck = false; recordResult(false, `ƒê·ªçc hi·ªÉu Q${i+1}`, userAnswer, `L·ªói API: ${error.message}`); stageFeedback.push(`C√¢u ${i+1}: L·ªói khi ki·ªÉm tra v·ªõi AI.`); userInputEl.style.borderColor = 'orange'; } } } showFeedback(allCorrectThisCheck, stageFeedback.join("\n\n")); submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra ƒê·ªçc Hi·ªÉu"; if (allCorrectThisCheck) { nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true; } }
        function loadSentenceCreationStage() { setInstructions("üí¨ M√†n 4.1: ƒê·∫∑t C√¢u. H√£y ƒë·∫∑t m·ªôt c√¢u ti·∫øng Trung ho√†n ch·ªânh s·ª≠ d·ª•ng t·ª´ cho s·∫µn."); const gameArea = gameAreaEl(); hintButtonEl()?.classList.remove('hidden'); currentSentenceCreationWordIndex = 0; displayCurrentSCWord(); }
        function displayCurrentSCWord() { const gameArea = gameAreaEl(); if (sentenceCreationWordsNew && currentSentenceCreationWordIndex < sentenceCreationWordsNew.length) { currentTargetWordForSC = sentenceCreationWordsNew[currentSentenceCreationWordIndex]; gameArea.innerHTML = ` <h3 class="stage-title">B√†i 4.1: ƒê·∫∑t C√¢u (${currentSentenceCreationWordIndex + 1}/${sentenceCreationWordsNew.length})</h3> <div id="sc-current-word-area"> <p><strong>H√£y ƒë·∫∑t c√¢u v·ªõi t·ª´:</strong></p> <span id="sc-current-word-hanzi">${currentTargetWordForSC.hanzi}</span> <span id="sc-current-word-pinyin">(${currentTargetWordForSC.pinyin})</span> <span id="sc-current-word-meaning">${currentTargetWordForSC.meaning}</span> </div> <textarea id="sc-sentence-input" rows="4" placeholder="Vi·∫øt c√¢u c·ªßa b·∫°n v√†o ƒë√¢y..."></textarea> <button id="submit-sc-sentence">Ki·ªÉm Tra C√¢u</button> `; getEl('submit-sc-sentence').addEventListener('click', handleSubmitSCCurrentSentence); clearFeedback(); clearHint(); nextStageButtonEl()?.classList.add('hidden'); } else { console.log("Ho√†n th√†nh M√†n 4.1 ƒê·∫∑t C√¢u."); loadNextStage(); } }
        async function handleSubmitSCCurrentSentence() { const sentenceInput = getEl('sc-sentence-input'); const sentence = sentenceInput ? sentenceInput.value.trim() : ''; if (!currentTargetWordForSC) { showFeedback(false, "L·ªói: Kh√¥ng c√≥ t·ª´ m·ª•c ti√™u."); return; } if (!sentence) { showFeedback(false, "B·∫°n ch∆∞a nh·∫≠p c√¢u!"); return; } const submitButton = getEl('submit-sc-sentence'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ch·∫•m ƒëi·ªÉm..."; clearFeedback(); const targetWordInfo = `${currentTargetWordForSC.hanzi} (${currentTargetWordForSC.pinyin}): ${currentTargetWordForSC.meaning}`; const prompt = `H·ªçc sinh ƒë∆∞·ª£c y√™u c·∫ßu ƒë·∫∑t c√¢u v·ªõi t·ª´ "${targetWordInfo}". C√¢u h·ªçc sinh ƒë·∫∑t l√†: "${sentence}". C√¢u n√†y c√≥ ƒë√∫ng ng·ªØ ph√°p, logic, t·ª± nhi√™n v√† s·ª≠ d·ª•ng ƒë√∫ng t·ª´ ƒë√£ cho kh√¥ng? Tr·∫£ l·ªùi b·∫Øt ƒë·∫ßu b·∫±ng "ƒê√°nh gi√°: [ƒê√∫ng/Sai]". N·∫øu Sai, ch·ªâ ra NG·∫ÆN G·ªåN l·ªói sai ch√≠nh v√† ƒë∆∞a ra 1 g·ª£i √Ω c·∫£i thi·ªán c√¢u. N·∫øu ƒê√∫ng, ch·ªâ c·∫ßn ghi "ƒê√°nh gi√°: ƒê√∫ng. C√¢u t·ªët."`; try { const aiResult = await callAI(prompt); recordResult(aiResult.isCorrect, `ƒê·∫∑t c√¢u (T·ª´: ${currentTargetWordForSC.hanzi})`, sentence, aiResult.isCorrect ? "" : aiResult.explanation); showFeedback(aiResult.isCorrect, aiResult.explanation); if (aiResult.isCorrect) { if (!getEl('submit-sc-sentence').dataset.counted) {totalQuestionsInGame++; getEl('submit-sc-sentence').dataset.counted = 'true';} currentSentenceCreationWordIndex++; setTimeout(displayCurrentSCWord, 1500); } else { submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra C√¢u"; } } catch (error) { showFeedback(false, `L·ªói API: ${error.message}`); submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra C√¢u"; } }
        function loadParagraphWritingStage() { setInstructions("‚úçÔ∏è M√†n 5.1: Vi·∫øt ƒêo·∫°n VƒÉn. H√£y vi·∫øt v·ªÅ s·ªü th√≠ch ƒÉn u·ªëng c·ªßa b·∫°n."); const gameArea = gameAreaEl(); hintButtonEl()?.classList.add('hidden'); if(gameStages.find(stage => stage === loadParagraphWritingStage) && !gameArea.dataset.questionsCounted) {totalQuestionsInGame++; gameArea.dataset.questionsCounted = 'true';} gameArea.innerHTML = ` <h3 class="stage-title">B√†i 5.1: ${paragraphWritingData.title}</h3> <div id="paragraph-writing-prompt"> <p>${paragraphWritingData.instructions.replace(/\n/g, '<br>')}</p> <h4>C·∫•u tr√∫c g·ª£i √Ω:</h4> <p>${paragraphWritingData.structureHint.replace(/\n/g, '<br>')}</p> <h4>T·ª´ v·ª±ng c√≥ th·ªÉ s·ª≠ d·ª•ng:</h4> <p>${paragraphWritingData.vocabHint.replace(/\n/g, '<br>')}</p> </div> <textarea id="paragraph-input" placeholder="Vi·∫øt ƒëo·∫°n vƒÉn c·ªßa b·∫°n v√†o ƒë√¢y (kho·∫£ng 100-150 ch·ªØ)..."></textarea> <div id="char-count">0/150 ch·ªØ</div> <button id="check-paragraph-writing">Ki·ªÉm Tra ƒêo·∫°n VƒÉn</button> `; const paragraphInputEl = getEl('paragraph-input'); const charCountEl = getEl('char-count'); paragraphInputEl.addEventListener('input', () => { const charLength = paragraphInputEl.value.length; charCountEl.textContent = `${charLength}/150 ch·ªØ`; if (charLength > 170) { charCountEl.style.color = 'red'; } else { charCountEl.style.color = '#6c757d'; } }); getEl('check-paragraph-writing').addEventListener('click', checkParagraphWriting); }
        async function checkParagraphWriting() { const paragraphInput = getEl('paragraph-input').value.trim(); if (paragraphInput.length < 80) { showFeedback(false, "ƒêo·∫°n vƒÉn c·ªßa b·∫°n h∆°i ng·∫Øn, h√£y vi·∫øt th√™m nh√© (√≠t nh·∫•t 80 ch·ªØ)."); return; } const submitButton = getEl('check-paragraph-writing'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback(); const prompt = `ƒê√°nh gi√° ƒëo·∫°n vƒÉn sau c·ªßa h·ªçc sinh vi·∫øt v·ªÅ ch·ªß ƒë·ªÅ '${paragraphWritingData.title}', y√™u c·∫ßu kho·∫£ng 100-150 ch·ªØ. ƒêo·∫°n vƒÉn: "${paragraphInput}". ƒê√°nh gi√° v·ªÅ s·ª± m·∫°ch l·∫°c, ng·ªØ ph√°p, t·ª´ v·ª±ng (c√≥ s·ª≠ d·ª•ng t·ª´ g·ª£i √Ω kh√¥ng?), v√† t√≠nh ph√π h·ª£p v·ªõi ch·ªß ƒë·ªÅ. Tr·∫£ l·ªùi b·∫Øt ƒë·∫ßu b·∫±ng "ƒê√°nh gi√°: [T·ªët/Kh√°/C·∫ßn c·∫£i thi·ªán]". Sau ƒë√≥ ƒë∆∞a ra nh·∫≠n x√©t t·ªïng quan v√† 2-3 g·ª£i √Ω c·∫£i thi·ªán NG·∫ÆN G·ªåN.`; try { const aiResult = await callAI(prompt); let isPass = !aiResult.explanation.toLowerCase().includes("c·∫ßn c·∫£i thi·ªán nhi·ªÅu"); recordResult(isPass, "Vi·∫øt ƒëo·∫°n B√†i 5.1", paragraphInput.substring(0,50)+"...", isPass ? "" : aiResult.explanation); showFeedback(isPass, aiResult.explanation); if (isPass) { nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true; } else { submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra ƒêo·∫°n VƒÉn"; } } catch (error) { showFeedback(false, `L·ªói API: ${error.message}`); submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra ƒêo·∫°n VƒÉn"; } }

        // ----- Summary Page -----
        function showSummary() { stopTimer(); const currentgameContainerEl = gameContainerEl(); const currentsummaryPageEl = summaryPageEl(); if (!currentgameContainerEl || !currentsummaryPageEl) return; currentgameContainerEl.classList.add('hidden'); currentsummaryPageEl.style.display = 'block'; currentsummaryPageEl.classList.remove('hidden'); getEl('summary-player-name').textContent = playerName || "·∫®n danh"; getEl('summary-time').textContent = gameResults.totalTime || 'N/A'; getEl('summary-correct').textContent = gameResults.correct || 0; getEl('total-questions-summary').textContent = totalQuestionsInGame || 0; getEl('summary-incorrect').textContent = gameResults.incorrect || 0; const errorsListEl = getEl('summary-errors'); if(errorsListEl) { errorsListEl.innerHTML = ''; if (gameResults.errors && gameResults.errors.length > 0) { gameResults.errors.forEach(err => { const li = document.createElement('li'); const shortInput = err.input && err.input.length > 100 ? err.input.substring(0, 97) + '...' : err.input; li.innerHTML = `<strong>M√†n ${err.stage}:</strong> ${err.issue} <br><small>(Input: ${shortInput || 'N/A'})</small>`; errorsListEl.appendChild(li); }); } else { errorsListEl.innerHTML = '<li>Ch√∫c m·ª´ng! B·∫°n kh√¥ng m·∫Øc l·ªói n√†o c·∫£ (ho·∫∑c c√°c b√†i t·ª± lu·∫≠n ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n)! ‚ú®</li>'; } } const submitReportButton = getEl('submit-report-button'); if (submitReportButton) { submitReportButton.disabled = false; submitReportButton.textContent = "N·ªôp B√°o C√°o L√™n Google Form üìã"; submitReportButton.style.backgroundColor = '#28a745'; submitReportButton.onclick = submitResultsToGoogleForm; } const restartButton = getEl('restart-button'); if (restartButton && !restartButton.dataset.listenerAttached) { restartButton.addEventListener('click', initGame); restartButton.dataset.listenerAttached = 'true'; } }

        // ----- Initialization -----
        function initGame() {
            console.log("Initializing new game: Êàë‰∏çÂêÉËøô‰∏™ (No Skip Button, Formatted Reading)");
            gameStages = [
                loadVocabMatchingStage, loadVocabFillStage, loadSentenceCompletionStage,
                loadReadingCompStage, loadSentenceCreationStage, loadParagraphWritingStage
            ];
            currentStage = 0; totalQuestionsInGame = 0;
            gameResults = { correct: 0, incorrect: 0, errors: [], totalTime: '00:00' };
            playerName = "";
            if (timerInterval) clearInterval(timerInterval); timerInterval = null;
            const currentTimerEl = timerEl(); if(currentTimerEl) currentTimerEl.textContent = '00:00';
            const currentgameContainerEl = gameContainerEl(); const currentsummaryPageEl = summaryPageEl(); const currentgameAreaEl = gameAreaEl(); const currentNextStageButtonEl = nextStageButtonEl(); const currentInstructionsEl = instructionsEl();

            if(currentgameContainerEl) currentgameContainerEl.classList.remove('hidden');
            if(currentsummaryPageEl) currentsummaryPageEl.style.display = 'none';
            if(currentgameAreaEl) currentgameAreaEl.innerHTML = '';
            clearFeedback(); clearHint();
            if(currentNextStageButtonEl) { currentNextStageButtonEl.classList.add('hidden'); if (!currentNextStageButtonEl.dataset.listenerAttached) { currentNextStageButtonEl.addEventListener('click', loadNextStage); currentNextStageButtonEl.dataset.listenerAttached = 'true';}}
            // Kh√¥ng c√≤n n√∫t skip ƒë·ªÉ x·ª≠ l√Ω ·ªü ƒë√¢y

            hideTooltip();
            if (currentInstructionsEl) currentInstructionsEl.innerHTML = `<p>üëã Ch√†o b·∫°n! Vui l√≤ng nh·∫≠p t√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu b√†i h·ªçc "T√¥i kh√¥ng ƒÉn c√°i n√†y".</p>`; // Icon m·ªõi
            if (currentgameAreaEl) {
                currentgameAreaEl.innerHTML = ` <div id="player-info" style="margin-bottom: 15px; padding: 20px; background-color: #e0f7fa; border-radius: 8px;"> <label for="player-name" style="display: block; margin-bottom: 8px; font-weight: bold;">T√™n c·ªßa b·∫°n:</label> <input type="text" id="player-name" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..." required style="width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;"> <button id="start-game-button" style="padding: 10px 20px;">B·∫Øt ƒë·∫ßu!</button> </div> `;
                const startButton = getEl('start-game-button'); const playerNameInput = getEl('player-name');
                if (startButton && playerNameInput) {
                    playerNameInput.addEventListener('keypress', function(event) { if (event.key === 'Enter') { event.preventDefault(); startButton.click(); } });
                    startButton.addEventListener('click', () => {
                        const name = playerNameInput.value.trim();
                        if (!name) { alert("Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!"); return; }
                        playerName = name; console.log("Player Name:", playerName);
                        startTimer();
                        loadNextStage();
                    });
                }
            }
            const currentHintButtonEl = hintButtonEl();
            if (currentHintButtonEl && !currentHintButtonEl.dataset.listenerAttached) { currentHintButtonEl.addEventListener('click', showHint); currentHintButtonEl.dataset.listenerAttached = 'true'; }
            else if (currentHintButtonEl) { currentHintButtonEl.classList.add('hidden'); currentHintButtonEl.disabled = false; }
        }

        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }

        // ----- START GAME -----
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>