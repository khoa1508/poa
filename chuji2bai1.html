<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Ti·∫øng Trung: B√†i 1 - ËÆ§ËØÜÊñ∞ÂêåÂ≠¶ üêº</title>
    <style>
        /* ----- CSS ----- */
        :root {
            --primary-color: #4A90E2; /* Xanh d∆∞∆°ng hi·ªán ƒë·∫°i */
            --secondary-color: #50E3C2; /* Xanh ng·ªçc lam */
            --success-color: #7ED321; /* Xanh l√° c√¢y t∆∞∆°i s√°ng */
            --warning-color: #F5A623; /* V√†ng cam */
            --danger-color: #D0021B; /* ƒê·ªè */
            --light-color: #FFFFFF; /* Tr·∫Øng tinh khi·∫øt */
            --bg-light-gray: #F4F7F6; /* X√°m r·∫•t nh·∫°t cho body */
            --card-bg-color: #FFFFFF; /* N·ªÅn tr·∫Øng cho card/section */
            --text-dark-color: #333333; /* M√†u ch·ªØ ch√≠nh ƒë·∫≠m */
            --text-light-color: #5F6368; /* M√†u ch·ªØ ph·ª• nh·∫°t h∆°n */
            --border-color: #E0E6ED; /* M√†u vi·ªÅn nh·∫°t */
            --font-family: 'Helvetica Neue', Arial, sans-serif;
            --cute-yellow: #FFF8E1; /* V√†ng kem nh·∫°t h∆°n */
        }

        body {
            font-family: var(--font-family);
            line-height: 1.7;
            background-color: var(--bg-light-gray);
            display: flex;
            justify-content: center;
            align-items: flex-start; /* ƒê·ªÉ padding top c√≥ t√°c d·ª•ng */
            min-height: 100vh;
            padding: 25px; /* TƒÉng padding body */
            margin: 0;
            color: var(--text-dark-color);
            box-sizing: border-box;
        }

        #game-container {
            background-color: var(--card-bg-color);
            padding: 30px 40px; /* TƒÉng padding */
            border-radius: 20px; /* Bo tr√≤n nhi·ªÅu h∆°n */
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.08); /* B√≥ng ƒë·ªï m·ªÅm m·∫°i h∆°n */
            max-width: 850px; /* TƒÉng nh·∫π max-width */
            width: 100%;
            text-align: center;
            box-sizing: border-box;
            opacity: 0;
            transform: translateY(15px);
            animation: fadeInUpSmooth 0.7s ease-out forwards 0.1s;
        }

        @keyframes fadeInUpSmooth {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 20px; /* TƒÉng margin bottom */
            font-size: 2.4em; /* TƒÉng k√≠ch th∆∞·ªõc */
            font-weight: 700; /* ƒê·∫≠m h∆°n */
        }

        #timer-section {
            font-size: 1.25em; /* TƒÉng k√≠ch th∆∞·ªõc */
            font-weight: 500;
            margin-bottom: 25px; /* TƒÉng margin */
            color: var(--primary-color);
            background-color: #E9F5FF; /* N·ªÅn xanh d∆∞∆°ng r·∫•t nh·∫°t */
            padding: 10px 15px;
            border-radius: 10px;
            display: inline-block; /* ƒê·ªÉ padding c√≥ t√°c d·ª•ng ƒë√∫ng */
        }

        #instructions p {
            background-color: var(--cute-yellow);
            border-left: 6px solid var(--warning-color); /* Vi·ªÅn d√†y h∆°n */
            padding: 18px 22px; /* TƒÉng padding */
            border-radius: 10px; /* Bo tr√≤n nhi·ªÅu h∆°n */
            margin-bottom: 25px;
            text-align: left;
            font-size: 1.1em;
            color: var(--text-light-color);
            box-shadow: 0 3px 8px rgba(245, 166, 35, 0.15); /* B√≥ng ƒë·ªï nh·∫π cho instruction */
        }
        #instructions p i { /* Emoji or icon */
            margin-right: 8px;
            font-size: 1.2em;
        }


        #game-area {
            margin-bottom: 25px;
            text-align: left;
        }

        .stage-title {
            font-size: 1.8em; /* TƒÉng k√≠ch th∆∞·ªõc */
            color: var(--secondary-color); /* D√πng m√†u ph·ª• */
            margin-bottom: 20px;
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color); /* Vi·ªÅn d∆∞·ªõi r√µ h∆°n */
        }

        /* M√†n 1.1: K√©o th·∫£ */
        #vocab-matching-area {
            display: flex;
            justify-content: space-between; /* C√°ch ƒë·ªÅu h∆°n */
            margin-bottom: 25px;
            min-height: 320px;
            flex-wrap: wrap;
            gap: 20px; /* Th√™m kho·∫£ng c√°ch gi·ªØa c√°c c·ªôt */
        }
        .vocab-list-column, .meaning-list-column {
            flex: 1; /* Cho ph√©p co gi√£n */
            min-width: 280px; /* TƒÉng ƒë·ªô r·ªông t·ªëi thi·ªÉu */
            padding: 15px; /* TƒÉng padding */
            border: 2px dashed var(--border-color); /* Vi·ªÅn r√µ h∆°n */
            border-radius: 10px;
            background-color: #F9FAFB; /* N·ªÅn x√°m r·∫•t nh·∫°t cho c·ªôt */
        }
        .draggable-item {
            background-color: var(--light-color);
            padding: 10px 15px; /* TƒÉng padding */
            margin: 8px 0; /* TƒÉng margin */
            border-radius: 8px; /* Bo tr√≤n nhi·ªÅu h∆°n */
            cursor: grab;
            border: 1px solid #E5E7EB; /* Vi·ªÅn nh·∫°t */
            text-align: center;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .draggable-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
        }
        .drop-target {
            background-color: #F0F9FF; /* N·ªÅn xanh nh·∫°t cho √¥ th·∫£ */
            padding: 18px 15px; /* TƒÉng padding */
            margin: 8px 0;
            border-radius: 8px;
            border: 2px dashed var(--primary-color);
            min-height: 45px; /* TƒÉng chi·ªÅu cao t·ªëi thi·ªÉu */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .drop-target.over { border-style: solid; background-color: #D6EFFF; border-color: var(--primary-color); }
        .drop-target.dropped-correct .draggable-item { background-color: var(--success-color); color: white; cursor: default; border-color: #6ABC74; }
        .drop-target.incorrect-drop .draggable-item { background-color: var(--danger-color); color: white; border-color: #C0392B; }


        /* M√†n 1.2: ƒêi·ªÅn t·ª´ (Dropdown) */
        .fill-sentence { margin-bottom: 15px; font-size: 1.15em; line-height: 2; }
        .fill-sentence select {
            padding: 8px 10px; /* TƒÉng padding */
            font-size: 1em;
            margin: 0 8px; /* TƒÉng margin */
            border-radius: 6px; /* Bo tr√≤n nhi·ªÅu h∆°n */
            border: 1px solid var(--border-color);
            background-color: var(--light-color);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.06);
            transition: border-color 0.2s ease;
        }
        .fill-sentence select:focus {
            border-color: var(--primary-color);
            outline: none;
        }


        /* M√†n 2.1: Ho√†n th√†nh c√¢u */
        .sentence-completion-item { margin-bottom: 18px; }
        .sentence-completion-item label { display: block; margin-bottom: 8px; font-weight: normal; line-height: 1.8; color: var(--text-light-color); }
        .sentence-completion-item input[type="text"] {
            width: calc(100% - 24px); /* Full width with padding */
            padding:10px 12px; /* TƒÉng padding */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 1.05em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .sentence-completion-item input[type="text"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.15);
            outline: none;
        }


        /* M√†n 3: ƒê·ªçc hi·ªÉu */
        .reading-passage-container {
            background-color: #F9FAFB; /* N·ªÅn x√°m r·∫•t nh·∫°t */
            padding: 20px; /* TƒÉng padding */
            border-radius: 10px;
            margin-bottom: 25px;
            line-height: 1.8; /* TƒÉng gi√£n d√≤ng */
            text-align: left;
            max-height: 350px; /* TƒÉng chi·ªÅu cao t·ªëi ƒëa */
            overflow-y: auto;
            border: 1px solid var(--border-color);
        }
        .reading-passage-container p { margin-bottom: 0 !important; /* Adjusted for dialogue */ padding: 3px 0; }
        .reading-passage-container .dialogue-line { margin-bottom: 0.5em; } /* Space between lines */
        .reading-narrative { color: var(--text-light-color); font-style: italic; margin-bottom: 12px !important; display: block; }
        .speaker { font-weight: 700; }
        .speaker-zhang { color: var(--speaker-zhang-color); }
        .speaker-pu { color: var(--speaker-pu-color); }
        .speaker-shanxia { color: var(--speaker-shanxia-color); }
        .speaker-feng { color: var(--speaker-feng-color); }
        .speaker-chen { color: var(--speaker-chen-color); }

        .reading-question { margin-bottom: 18px; }
        .reading-question label { display: block; margin-bottom: 8px; font-weight: 500; /* ƒê·∫≠m v·ª´a */ }
        .reading-question textarea, .reading-question input[type="text"] {
            width: calc(100% - 24px); /* Full width with padding */
            padding: 12px; /* TƒÉng padding */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            min-height: 35px;
            font-size: 1em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .reading-question textarea:focus, .reading-question input[type="text"]:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.15);
            outline: none;
        }


        /* M√†n 4.1: ƒê·∫∑t c√¢u (t·ª´ng t·ª´) */
        #sc-current-word-area {
            margin-bottom: 25px;
            padding: 20px; /* TƒÉng padding */
            background-color: var(--cute-yellow);
            border-radius: 12px; /* Bo tr√≤n nhi·ªÅu h∆°n */
            text-align: center;
            border: 1px solid #FDE68A; /* Vi·ªÅn v√†ng nh·∫°t */
        }
        #sc-current-word-hanzi { font-size: 2em; font-weight: 700; display: block; margin-bottom: 8px; color: var(--primary-color); }
        #sc-current-word-pinyin { font-size: 1.2em; color: var(--text-light-color); display: block;}
        #sc-current-word-meaning { font-size: 1.05em; color: #71717A; display: block; margin-top: 8px; font-style: italic;}
        #sc-sentence-input {
            box-sizing: border-box;
            width: 100%;
            padding: 18px; /* TƒÉng padding */
            font-size: 1.15em; /* TƒÉng font size */
            border: 1px solid var(--border-color);
            border-radius: 8px;
            min-height: 90px; /* TƒÉng chi·ªÅu cao */
            margin-bottom: 20px;
            display: block;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
         #sc-sentence-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.15);
            outline: none;
        }


        /* M√†n 5.1: Vi·∫øt ƒëo·∫°n */
        #paragraph-writing-prompt {
            background-color: #E9F5FF; /* N·ªÅn xanh d∆∞∆°ng r·∫•t nh·∫°t */
            padding: 20px; /* TƒÉng padding */
            border-radius: 10px;
            margin-bottom: 15px;
            text-align: left;
            font-size: 1em; /* TƒÉng nh·∫π font size */
            border: 1px solid #BEE3F8; /* Vi·ªÅn xanh nh·∫°t */
        }
        #paragraph-writing-prompt h4 { margin-top: 0; color: var(--primary-color); }
        #paragraph-input {
            width: calc(100% - 24px); /* Full width with padding */
            min-height: 180px; /* TƒÉng chi·ªÅu cao */
            padding: 15px; /* TƒÉng padding */
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1.05em;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        #paragraph-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.15);
            outline: none;
        }
        #char-count { font-size: 0.95em; color: var(--text-light-color); text-align: right; margin-top: 5px; }


        #feedback-section {
            margin-top: 20px;
            padding: 15px 20px; /* TƒÉng padding */
            border-radius: 8px;
            min-height: 35px; /* TƒÉng chi·ªÅu cao t·ªëi thi·ªÉu */
            display: none;
            word-wrap: break-word;
            text-align: left;
            font-size: 1.05em; /* TƒÉng font size */
            box-shadow: 0 3px 8px rgba(0,0,0,0.07);
        }
        #feedback-section.correct { background-color: #E6FFFA; color: #047857; border: 1px solid #99F6E4;} /* Xanh mint */
        #feedback-section.incorrect { background-color: #FFF1F2; color: #C21E3D; border: 1px solid #FFD6D9;} /* H·ªìng nh·∫°t */
        #feedback-section.info { background-color: #EBF8FF; color: #2C5282; border: 1px solid #BEE3F8;} /* Xanh d∆∞∆°ng nh·∫°t */
        #feedback-section strong { display: block; margin-bottom: 8px; font-weight: 600;}

        button { /* N√∫t b·∫•m chung, c√≥ th·ªÉ t√πy ch·ªânh th√™m cho t·ª´ng lo·∫°i */
            background-image: linear-gradient(to right, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            border: none;
            padding: 14px 30px; /* TƒÉng padding */
            border-radius: 30px; /* Bo tr√≤n nhi·ªÅu h∆°n (h√¨nh vi√™n thu·ªëc) */
            cursor: pointer;
            font-size: 1.05em; /* TƒÉng nh·∫π font size */
            font-weight: 600; /* ƒê·∫≠m h∆°n */
            transition: all 0.3s ease;
            margin: 10px 5px;
            letter-spacing: 0.5px; /* Th√™m kho·∫£ng c√°ch ch·ªØ */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            opacity: 0.9;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        button:disabled {
            background-image: none;
            background-color: #D1D5DB; /* M√†u x√°m cho n√∫t b·ªã v√¥ hi·ªáu h√≥a */
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #summary-page {
            background-color: #F0F9FF; /* N·ªÅn xanh d∆∞∆°ng r·∫•t nh·∫°t */
            padding: 35px; /* TƒÉng padding */
            border-radius: 15px;
            margin-top: 30px;
            text-align: left;
            display: none;
            border: 2px solid var(--primary-color); /* Vi·ªÅn r√µ h∆°n */
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
        }
        #summary-page h2 { text-align: center; color: var(--primary-color); font-size: 1.9em; margin-bottom: 25px;}
        #summary-page p { font-size: 1.15em; margin-bottom: 12px;}
        #summary-errors { padding-left: 0; list-style-type: none; } /* B·ªè d·∫•u ƒë·∫ßu d√≤ng m·∫∑c ƒë·ªãnh */
        #summary-errors li {
            color: var(--danger-color);
            margin-bottom: 8px;
            padding: 10px; /* TƒÉng padding */
            background-color: #FFF1F2; /* N·ªÅn h·ªìng nh·∫°t cho l·ªói */
            border-radius: 6px;
            border-left: 4px solid var(--danger-color);
        }
        #summary-errors li strong { color: var(--text-dark-color); }
        #summary-errors small { color: #718096; display: block; margin-top: 4px; } /* M√†u x√°m cho chi ti·∫øt l·ªói */

        .hidden { display: none !important; }
        #skip-stage-button {
            background-image: linear-gradient(to right, var(--warning-color) 0%, #FBBF24 100%); /* Gradient v√†ng */
            color: var(--text-dark-color);
            margin-left: 15px;
        }
        #hint-button {
             background-image: linear-gradient(to right, #A78BFA 0%, #7C3AED 100%); /* Gradient t√≠m */
        }
        #restart-button {
             background-image: linear-gradient(to right, var(--secondary-color) 0%, #34D399 100%); /* Gradient xanh ng·ªçc */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Game Ti·∫øng Trung: B√†i 1 - ËÆ§ËØÜÊñ∞ÂêåÂ≠¶ ü§ù</h1>
        <div id="timer-section">‚è≥ Th·ªùi gian: <span id="timer">00:00</span></div>
        <div id="instructions"><p>üíñ Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi B√†i 1! H√£y c√πng kh√°m ph√° nh√©!</p></div>
        <div id="game-area"></div>
        <div id="hint-section" style="text-align: center; margin-top:15px;"><button id="hint-button" class="hidden">üí° G·ª£i √Ω cho t√¥i n√†o!</button><p id="hint-text" style="margin-top:10px; font-style:italic; color: var(--text-light-color);"></p></div>
        <div id="feedback-section"><p id="feedback-text"></p></div>
        <div id="navigation-buttons" style="margin-top: 25px; text-align: center;">
            <button id="next-stage-button" class="hidden">Ti·∫øp t·ª•c M√†n Sau ‚ñ∂Ô∏è</button>
            <button id="skip-stage-button">B·ªè Qua M√†n N√†y (Test) ‚è©</button>
        </div>
    </div>
    <div id="summary-page">
        <h2>üéâ Ho√†n Th√†nh B√†i H·ªçc! üéâ</h2>
        <p>T√™n h·ªçc vi√™n: <span id="summary-player-name"></span></p>
        <p>T·ªïng th·ªùi gian: <span id="summary-time"></span></p>
        <p>S·ªë c√¢u ƒë√∫ng: <span id="summary-correct"></span> (T·ªïng s·ªë m·ª•c ƒë√£ l√†m: <span id="total-questions-summary"></span>)</p>
        <p>S·ªë c√¢u sai/ch∆∞a ho√†n h·∫£o: <span id="summary-incorrect"></span></p>
        <h3>Chi ti·∫øt l·ªói/nh·∫≠n x√©t:</h3>
        <ul id="summary-errors"></ul>
        <button id="restart-button">Ch∆°i l·∫°i t·ª´ ƒë·∫ßu üîÅ</button>
        </div>

    <script>
        // ----- D·ªÆ LI·ªÜU TR√í CH∆†I B√ÄI 1: ËÆ§ËØÜÊñ∞ÂêåÂ≠¶ -----
        const vocabMatchingData_B1 = [
            { id: 1, hanzi: 'Êô∫ÊÖß', pinyin: 'zh√¨hu√¨', meaning: 'tr√≠ tu·ªá / wisdom' },
            { id: 2, hanzi: 'Êù•Ëá™', pinyin: 'l√°iz√¨', meaning: 'ƒë·∫øn t·ª´ / come from' },
            { id: 3, hanzi: 'ËØó(Ê≠å)', pinyin: 'shƒ´(gƒì)', meaning: 'th∆° ca / poetry' },
            { id: 4, hanzi: 'Âì≤Â≠¶', pinyin: 'zh√©xu√©', meaning: 'tri·∫øt h·ªçc / philosophy' },
            { id: 5, hanzi: 'Â∞ÜÊù•', pinyin: 'jiƒÅngl√°i', meaning: 't∆∞∆°ng lai / future' },
            { id: 6, hanzi: 'ËÆ°Âàí', pinyin: 'j√¨hu√†', meaning: 'k·∫ø ho·∫°ch / plan' },
            { id: 7, hanzi: 'ÈÄöËøá', pinyin: 't≈çnggu√≤', meaning: 'th√¥ng qua, v∆∞·ª£t qua / pass' },
            { id: 8, hanzi: 'ÊµÅÂà©', pinyin: 'li√∫l√¨', meaning: 'l∆∞u lo√°t / fluent' },
            { id: 9, hanzi: '‰ºòÁßÄ', pinyin: 'y≈çuxi√π', meaning: '∆∞u t√∫, xu·∫•t s·∫Øc / excellent' },
            { id: 10, hanzi: 'Â≠îÂ≠ê', pinyin: 'K«íngz«ê', meaning: 'Kh·ªïng T·ª≠ / Confucius' },
            { id: 11, hanzi: 'ÂêõÂ≠ê', pinyin: 'j≈´nz«ê', meaning: 'qu√¢n t·ª≠ / man of noble virtue' },
            { id: 12, hanzi: 'ÂêõÂ≠êÂ∞öÂæ∑', pinyin: 'j≈´nz«ê sh√†ng d√©', meaning: 'ng∆∞·ªùi qu√¢n t·ª≠ coi tr·ªçng ƒë·ª©c h·∫°nh / an exemplary person esteems virtue' },
            { id: 13, hanzi: 'ÊÄùËÄÉ', pinyin: 'sƒ´k«éo', meaning: 'suy nghƒ©, t∆∞ duy / think' },
            { id: 14, hanzi: 'Á°ÆÂÆû', pinyin: 'qu√®sh√≠', meaning: 'qu·∫£ th·ª±c, th·ª±c s·ª± / indeed' },
            { id: 15, hanzi: 'ÊØîÂ¶Ç', pinyin: 'b«êr√∫', meaning: 'v√≠ d·ª• / for example' },
            { id: 16, hanzi: 'ÊïôËÇ≤', pinyin: 'ji√†oy√π', meaning: 'gi√°o d·ª•c / education; educate' },
            { id: 17, hanzi: 'Êâì‰∫§ÈÅì', pinyin: 'd«é jiƒÅodao', meaning: 'giao ti·∫øp, ti·∫øp x√∫c / have dealings with' },
            { id: 18, hanzi: 'ËÅîÁ≥ª', pinyin: 'li√°nx√¨', meaning: 'li√™n h·ªá, k·∫øt n·ªëi / contact; connect' },
            { id: 19, hanzi: 'ÂØÜÂàá', pinyin: 'm√¨qi√®', meaning: 'm·∫≠t thi·∫øt, th√¢n thi·∫øt / close' },
            { id: 20, hanzi: 'Êú¨Áßë', pinyin: 'bƒõnkƒì', meaning: 'ƒë·∫°i h·ªçc (c·ª≠ nh√¢n) / undergraduate course' },
            { id: 21, hanzi: 'ÊØï‰∏ö', pinyin: 'b√¨y√®', meaning: 't·ªët nghi·ªáp / graduate' }
        ];

        const vocabFillData_B1_Set1 = {
            options: ["Â∞ÜÊù•", "Êù•Ëá™", "ÈÄöËøá", "Âì≤Â≠¶", "ËÆ°Âàí", "ÊµÅÂà©"],
            sentences: [
                { parts: ["ÊàëÂè´ÈôàÊñ∞Èò≥, ", { placeholderID: "vf1_1_1", answer: "Êù•Ëá™" }, " È©¨Êù•Ë•ø‰∫ö„ÄÇÊàëÂñúÊ¨¢‰∏≠ÂõΩËØóÊ≠å, ÊâìÁÆó ", { placeholderID: "vf1_1_2", answer: "Â∞ÜÊù•" }, " ÂÅöÊ±âËØ≠ËÄÅÂ∏à„ÄÇÊàëË¶ÅÂä™ÂäõÂ≠¶‰π†, Â∏åÊúõ‰∫åÂπ¥Á∫ßËÉΩ ", { placeholderID: "vf1_1_3", answer: "ÈÄöËøá" }, " HSK6Á∫ßËÄÉËØï„ÄÇ"] },
                { parts: ["ÊàëÂñúÊ¨¢‰∏≠ÂõΩ ", { placeholderID: "vf1_2_1", answer: "Âì≤Â≠¶" }, ", ÊâÄ‰ª•ÊàëÊù•‰∏≠ÂõΩÁïôÂ≠¶„ÄÇÊàë ", { placeholderID: "vf1_2_2", answer: "ËÆ°Âàí" }, " Â•ΩÂ•ΩÂ≠¶‰π†Ê±âËØ≠, Â∏åÊúõÂà∞‰∏âÂπ¥Á∫ßËÉΩ ", { placeholderID: "vf1_2_3", answer: "ÊµÅÂà©" }, " Âú∞ËØ¥Ê±âËØ≠, ‰πüËÉΩËØªÊáÇÂ≠îÂ≠êËØ¥ËøáÁöÑËØù„ÄÇ"] }
            ]
        };

        const vocabFillData_B1_Set2 = {
            options: ["Êú¨Áßë", "Êâì‰∫§ÈÅì", "ÊØï‰∏ö", "Á°ÆÂÆû", "ËÅîÁ≥ª", "ÊØîÂ¶Ç"],
            sentences: [
                { parts: ["ÊàëÊòØ ", { placeholderID: "vf2_3_1", answer: "Êú¨Áßë" }, " ‰∏ÄÂπ¥Á∫ßÁöÑÂ≠¶Áîü, Â≠¶‰π†Ê±âËØ≠‰∏ì‰∏ö„ÄÇÊàëÊâìÁÆó ", { placeholderID: "vf2_3_2", answer: "ÊØï‰∏ö" }, " ‰ª•ÂêéÂΩì‰∏ÄÂêçÂ∞èÂ≠¶ËÄÅÂ∏à„ÄÇÊØèÂ§©ÂíåÂ≠©Â≠ê‰ª¨ ", { placeholderID: "vf2_3_3", answer: "Êâì‰∫§ÈÅì" }, " Â§öÂºÄÂøÉÂïä!"] },
                { parts: ["Êù•‰∏≠ÂõΩ‰ª•Âêé, ÊàëÁªèÂ∏∏ÊÄùËÄÉ‰∏Ä‰∫õÈóÆÈ¢ò„ÄÇ ", { placeholderID: "vf2_4_1", answer: "ÊØîÂ¶Ç" }, " , ÊàëÁöÑÊ±âËØ≠Ëøò‰∏çÂ§™ÊµÅÂà©, Áî®Ê±âËØ≠ËØ¥ËØù ", { placeholderID: "vf2_4_2", answer: "Á°ÆÂÆû" }, " ÊúâÁÇπÂÑøÈöæ, ÊâÄ‰ª•ÊàëÂæóÂ§ö ", { placeholderID: "vf2_4_3", answer: "ËÅîÁ≥ª" }, " ÊàëÁöÑ‰∏≠ÂõΩÊúãÂèã‰ª¨, Â§öÂíå‰ªñ‰ª¨ÁªÉ‰π†Âè£ËØ≠„ÄÇ"] }
            ]
        };

        const sentenceCompletionData_B1 = [
            { id: "scb1_1", starter: "ÊàëÁöÑÂêçÂ≠ó", hint: "Áà∏Áà∏ÁªôËµ∑ÁöÑÔºå‰ªñÂ∏åÊúõÊàë", exampleSuffix: "„ÄÇ(G·ª£i √Ω: Â∏åÊúõ...)" },
            { id: "scb1_2", starter: "Êàë", hint: "Âæ∑ÂõΩÔºåÊàëÁöÑ‰∏ì‰∏öÊòØ", exampleSuffix: "„ÄÇ(G·ª£i √Ω: Êù•Ëá™)" },
            { id: "scb1_3", starter: "ÊàëÂØπ", hint: "ÁâπÂà´ÊÑüÂÖ¥Ë∂£ÔºåÊâÄ‰ª•ÊàëÈÄâÊã©Â≠¶‰π†Ëøô‰∏™‰∏ì‰∏ö„ÄÇ", exampleSuffix: "(G·ª£i √Ω: ÂØπ...ÊÑüÂÖ¥Ë∂£)" },
            { id: "scb1_4", starter: "", hint: "Ê±âËØ≠Â•ΩÁöÑËØùÔºå", exampleSuffix: "ÊØîËæÉÂÆπÊòìÊâæÂà∞Â•ΩÂ∑•‰Ωú„ÄÇ(G·ª£i √Ω: ...ÁöÑËØùÔºåÂ∞±...)" },
            { id: "scb1_5", starter: "ÊàëÊâìÁÆó", hint: "ÔºåÂ∏åÊúõÂ∞ÜÊù•ËÉΩ", exampleSuffix: "„ÄÇ(G·ª£i √Ω: ÊâìÁÆó..., Â∏åÊúõ...)" },
            { id: "scb1_6", starter: "Èô§‰∫Ü", hint: "‰ª•Â§ñÔºåÊàëËøòÊÉ≥", exampleSuffix: "„ÄÇ(G·ª£i √Ω: Èô§‰∫Ü...‰ª•Â§ñÔºåËøò... )" },
            { id: "scb1_7", starter: "ÊàëÊÉ≥Âêë", hint: "Â≠¶‰π†ÔºåÊää", exampleSuffix: "‰ªãÁªçÁªô", hint2: "„ÄÇ(G·ª£i √Ω: Âêë...Â≠¶‰π†ÔºåÊää...‰ªãÁªçÁªô... )" }
        ];

        const KET_VAN_1_TEXT = `(Êñ∞Â≠¶Êúü,ÂÖ®Áè≠Ë¶ÅËÅöÈ§ê,Â§ßÂÆ∂Ê≠£Âú®ÂïÜÈáèÂéªÂêÉ‰ªÄ‰πà„ÄÇ)
<span class="speaker speaker-zhang">Âº†Â∞èËñá:</span> ÂêåÂ≠¶‰ª¨,Âë®‰∫î‰∏ãËØæÂêéÊàë‰ª¨‰∏ÄËµ∑ÂéªÂêÉ‰∏™È•≠ÊÄé‰πàÊ†∑?
<span class="speaker speaker-pu">Êú¥Êô∫ÊÖß:</span> Â•ΩÂïä,‰Ω†‰ª¨ÊÉ≥ÂêÉ‰ªÄ‰πà?
<span class="speaker speaker-shanxia">Â±±‰∏ãÂíå‰πü:</span> ÂéªÂêÉÂõõÂ∑ùÁÅ´ÈîÖÂêß!Êàë‰∏ÄÁõ¥ÈÉΩÊÉ≥ËØïËØïÂ∑ùËèú„ÄÇ
<span class="speaker speaker-pu">Êú¥Êô∫ÊÖß:</span> ÂõõÂ∑ùÁÅ´ÈîÖ?ÊàëÂíåÊúãÂèãÂêÉËøá‰∏ÄÊ¨°,Ëæ£ÂæóÊàëÁõ¥ÊµÅÁúºÊ≥™„ÄÇÊàëÂèó‰∏ç‰∫Ü‰∏≠ÂõΩÁöÑËæ£Ê§í,‰πü‰∏çÂ§™ÂñúÊ¨¢ÁæäËÇâ„ÄÇ
<span class="speaker speaker-feng">ÂÜØÂ∞öÂæ∑:</span> ÈÇ£Âí±‰ª¨Êç¢‰∏™È•≠È¶Ü„ÄÇÂ±±‰∏ã,Êó•Êú¨‰∫∫ÈÉΩ‰∏çÂêÉÁæäËÇâÂêó?
<span class="speaker speaker-shanxia">Â±±‰∏ãÂíå‰πü:</span> Â§ßÈÉ®ÂàÜÊó•Êú¨‰∫∫ÈÉΩ‰∏çÂ§™ÂñúÊ¨¢ÁæäËÇâ„ÄÇÊó•Êú¨È•ÆÈ£üÊ∏ÖÊ∑°,ÊâÄ‰ª•Âë≥ÈÅìÊØîËæÉÈáçÁöÑÈ£üÁâ©‰∏çÂ§™ÂèóÊ¨¢Ëøé,ÂåÖÊã¨Âä®Áâ©ÁöÑÂÜÖËÑè„ÄÇ
<span class="speaker speaker-zhang">Âº†Â∞èËñá:</span> ÊàëËßâÂæóÊúÄÂ•ΩÊâæ‰∏Ä‰∏™Ê∏ÖÁúüÈ•≠È¶Ü,Êñ∞Èò≥ÊòØÁ©ÜÊñØÊûó„ÄÇ
<span class="speaker speaker-chen">ÈôàÊñ∞Èò≥:</span> Ë∞¢Ë∞¢Â∞èËñá!Êàë‰∏çÂêÉÈùûÊ∏ÖÁúüÁöÑËÇâÈ£ü„ÄÇ
<span class="speaker speaker-feng">ÂÜØÂ∞öÂæ∑:</span> ÈÇ£Êàë‰ª¨ÂéªÂêÉ‰ªÄ‰πà?Â∞èËñá,‰Ω†Áü•ÈÅìÂì™ÂÑøÊúâÂ•ΩÂêÉÁöÑÂêó?
<span class="speaker speaker-zhang">Âº†Â∞èËñá:</span> ÊàëÊÉ≥ÊÉ≥„ÄÇÂ∞öÂæ∑„ÄÅÊô∫ÊÖß,‰Ω†‰ª¨‰ø©Êúâ‰ªÄ‰πà‰∏çÂêÉÁöÑÂêó?ÂØπ‰ªÄ‰πàÈ£üÁâ©ËøáÊïè?
<span class="speaker speaker-feng">ÂÜØÂ∞öÂæ∑:</span> ËøáÊïèÂÄíÊ≤°Êúâ,‰ΩÜÊòØÊàë‰πü‰∏çÂñúÊ¨¢ÂêÉÂÜÖËÑè„ÄÅÈ∏°Áà™Â≠ê‰πãÁ±ªÁöÑ„ÄÇÂÜÖËÑèÊúâÁßçÂ•áÊÄ™ÁöÑÂë≥ÈÅì,È∏°Áà™Â≠êÁúãËµ∑Êù•ÂÉè‰∫∫ÁöÑÊâã„ÄÇÂØπÊàëÊù•ËØ¥Ëøô‰∫õÈÉΩÊòØ‚ÄúÈªëÊöóÊñôÁêÜ‚Äù„ÄÇ
<span class="speaker speaker-pu">Êú¥Êô∫ÊÖß:</span> Êàë‰∏çÊÉ≥ÂêÉÂø´È§êÁ≠âÂ§™Ê≤πËÖªÁöÑÈ£üÁâ©,‰∏çÂÅ•Â∫∑,ÊúÄÂÖ≥ÈîÆÁöÑÊòØÂêÉ‰∏ÄÂè£Â∞±ËÉñ„ÄÇ‰∏çËøáËøôÊ†∑‰∏ÄÊù•,‰πüÂ∞ë‰∫ÜÂæàÂ§öÂêÉÂø´È§êÁöÑÂø´‰πê„ÄÇ
<span class="speaker speaker-zhang">Âº†Â∞èËñá:</span> ÂèàÂ•ΩÂêÉÂèàÂÅ•Â∫∑ÁöÑÁÉ§È±º?
<span class="speaker speaker-shanxia">Â±±‰∏ãÂíå‰πü</span>„ÄÅ<span class="speaker speaker-chen">ÈôàÊñ∞Èò≥</span>„ÄÅ<span class="speaker speaker-feng">ÂÜØÂ∞öÂæ∑</span>„ÄÅ<span class="speaker speaker-pu">Êú¥Êô∫ÊÖß:</span> ÂêåÊÑè!
<span class="speaker speaker-zhang">Âº†Â∞èËñá:</span> ÈÇ£Êàë‰ª¨ÂéªÂêÉÊ∏ÖÁúüÁÉ§È±ºÂêß,ÊúâËæ£ÁöÑ,‰πüÊúâ‰∏çËæ£ÁöÑ,ËøòÂèØ‰ª•Êîæ‰∫õËî¨Ëèú„ÄÇ`;

        const readingCompData_B1_B = {
            title: "Ph·∫ßn 3.B: ƒê·ªçc ËØæÊñá(‰∏Ä) v√† tr·∫£ l·ªùi",
            passage: KET_VAN_1_TEXT, // S·ª≠ d·ª•ng bi·∫øn ƒë√£ format
            questions: [
                { id: "rcB_1", promptBefore: "‰∏∫‰ªÄ‰πàÂè´Ëøô‰∏™ÂêçÂ≠óÔºüÊú¥Êô∫ÊÖßÔºö (Â∏åÊúõ, ËÅ™Êòé) ", promptAfter: ""},
                { id: "rcB_2", promptBefore: "È©¨Ê≥¢ÁΩóÔºö (Âêë‚Ä¶Â≠¶‰π†, Êää) ", promptAfter: ""},
                { id: "rcB_3", promptBefore: "ÂÜØÂ∞öÂæ∑Ôºö (Â≠îÂ≠ê, ÂêõÂ≠ê) ", promptAfter: ""},
                { id: "rcB_4", promptBefore: "‰∏∫‰ªÄ‰πàÂ≠¶Ê±âËØ≠ÔºüÈôàÊñ∞Èò≥Ôºö (ËØóÊ≠å) ", promptAfter: ""},
                { id: "rcB_5", promptBefore: "ÂÜØÂ∞öÂæ∑Ôºö (ÂØπ‚Ä¶ÊÑüÂÖ¥Ë∂£) ", promptAfter: ""},
                { id: "rcB_6", promptBefore: "Â±±‰∏ãÂíå‰πüÔºö (‚Ä¶ÁöÑËØù) ", promptAfter: ""},
                { id: "rcB_7", promptBefore: "Êú¥Êô∫ÊÖßÔºö (Â∞ÜÊù•) ", promptAfter: ""},
                { id: "rcB_8", promptBefore: "È©¨Ê≥¢ÁΩóÔºö (ÂÉè‚Ä¶ÈÇ£Ê†∑) ", promptAfter: ""},
                { id: "rcB_9", promptBefore: "Âº†Â∞èËñáÔºö (‰∫ÜËß£) ", promptAfter: ""}
            ],
            subQuestionsLearningPlan: [
                { id: "rcB_lp1", promptBefore: "ÊúâÂì™‰∫õÂ≠¶‰π†ËÆ°ÂàíÔºüÈôàÊñ∞Èò≥Ôºö (ÊâìÁÆó, ÈÄöËøá) ", promptAfter: ""},
                { id: "rcB_lp2", promptBefore: "Â±±‰∏ãÂíå‰πüÔºö (ÂÖà‚Ä¶, ÂçäÂπ¥‰ª•Âêé‚Ä¶) ", promptAfter: ""},
                { id: "rcB_lp3", promptBefore: "È©¨Ê≥¢ÁΩóÔºö (Âæó, ÊµÅÂà©) ", promptAfter: ""},
                { id: "rcB_lp4", promptBefore: "Âº†Â∞èËñáÔºö (ÊÉ≥, ‰ºòÁßÄ) ", promptAfter: ""}
            ]
        };

        const DOAN_VAN_1_TEXT = `ÊàëÂè´‰∏ÅÊÄùÊÄù„ÄÇÊàëÁöÑÂêçÂ≠óÊòØÊàëÁà∏Áà∏ÁªôËµ∑ÁöÑ„ÄÇÊàëÁà∏Áà∏Â∏åÊúõÊàëÂÅö‰∏Ä‰∏™ÊúâÊô∫ÊÖßÁöÑ‰∫∫ÔºåÈÅá‰∫ãÂ§öÊÄùËÄÉÔºåÊâÄ‰ª•ÁªôÊàëËµ∑‰∫ÜËøô‰∏™ÂêçÂ≠ó„ÄÇÊàëÂ∏∏Â∏∏ÊÄùËÄÉÂêÑÁßçÂêÑÊ†∑ÁöÑÈóÆÈ¢òÔºåÊØîÂ¶ÇÔºåÊàë‰∏∫‰ªÄ‰πàË¶ÅÂ≠¶‰π†ÔºüÊàëÂ∞ÜÊù•Ë¶ÅÂÅö‰ªÄ‰πàÊ†∑ÁöÑ‰∫∫Ôºü ÊàëÊòØÊ≤≥ÂÜÖÂõΩÂÆ∂Â§ßÂ≠¶‰∏ãÂ±ûÂ§ñÂõΩËØ≠Â§ßÂ≠¶ÊïôËÇ≤Â≠¶Èô¢Êú¨Áßë‰∏ÄÂπ¥Á∫ßÁöÑÂ≠¶ÁîüÔºåÂ≠¶‰π†Ê±âËØ≠ÊïôËÇ≤‰∏ì‰∏ö„ÄÇÊàëÊù•Ëá™Ë∂äÂçóÈ¶ñÈÉΩÊ≤≥ÂÜÖ„ÄÇ ÊàëÈÄâÊã©Ëøô‰∏™‰∏ì‰∏öÔºå‰∏ªË¶ÅÊòØÂõ†‰∏∫ÊàëÂØπ‰∏≠ÂõΩÊñáÂåñÂæàÊÑüÂÖ¥Ë∂£ÔºåÁâπÂà´ÊòØ‰∏≠ÂõΩÂè§‰ª£Âì≤Â≠¶ÂíåÊïôËÇ≤ÊÄùÊÉ≥„ÄÇÊàëÂ∏åÊúõÂ∞ÜÊù•ËÉΩÊàê‰∏∫‰∏ÄÂêç‰ºòÁßÄÁöÑÊ±âËØ≠ËÄÅÂ∏àÔºåÊää‰∏≠ÂõΩÊñáÂåñ‰ªãÁªçÁªôÊõ¥Â§öÁöÑË∂äÂçóÂ≠¶Áîü„ÄÇ‰∏∫‰∫ÜÂÆûÁé∞Ëøô‰∏™ÁõÆÊ†áÔºåÊàëËÆ°ÂàíÂú®Â§ßÂ≠¶ÊúüÈó¥Âä™ÂäõÂ≠¶‰π†‰∏ì‰∏öÁü•ËØÜÔºåÂ§öË∑ü‰∏≠ÂõΩËÄÅÂ∏àÂíåÂêåÂ≠¶Êâì‰∫§ÈÅìÔºåÊèêÈ´òËá™Â∑±ÁöÑÊ±âËØ≠Ê∞¥Âπ≥„ÄÇÊàëËøòÊâìÁÆóÁî≥ËØ∑Âéª‰∏≠ÂõΩ‰∫§ÊµÅÂ≠¶‰π†‰∏ÄÂπ¥Ôºå‰∫≤Ë∫´‰ΩìÈ™å‰∏≠ÂõΩÊñáÂåñ„ÄÇÊØï‰∏ö‰ª•ÂêéÔºåÊàëÊÉ≥ÂÖàÂú®‰∏ÄÊâÄ‰∏≠Â≠¶ÂΩìÊ±âËØ≠ËÄÅÂ∏àÔºåÁßØÁ¥Ø‰∏Ä‰∫õÊïôÂ≠¶ÁªèÈ™åÔºåÁÑ∂ÂêéÂÜçËÄÉËôëËØªÁ†îÁ©∂Áîü„ÄÇ ÊàëËßâÂæóÂíåÂ≠¶Áîü‰ª¨Êâì‰∫§ÈÅìÊòØ‰∏Ä‰ª∂ÈùûÂ∏∏ÊúâÊÑèÊÄùÁöÑ‰∫ãÊÉÖÔºåËÉΩÂ∏ÆÂä©‰ªñ‰ª¨Â≠¶‰π†ÂíåÊàêÈïøÔºåÊàëÊÑüÂà∞ÂæàÂºÄÂøÉ„ÄÇÊàëÁõ∏‰ø°ÔºåÂè™Ë¶ÅÊàëÂä™ÂäõÔºåÊàëÁöÑÁêÜÊÉ≥‰∏ÄÂÆöËÉΩÂÆûÁé∞„ÄÇ `;

        const readingCompData_B1_C = {
            title: "Ph·∫ßn 3.C: ƒê·ªçc Áü≠Êñá(‰∏Ä) (‰∏ÅÊÄùÊÄù) v√† tr·∫£ l·ªùi",
            passage: DOAN_VAN_1_TEXT,
            questions: [
                { id: "rcC_1", text: "Â•πÂè´‰ªÄ‰πàÂêçÂ≠óÔºüÁà∏Áà∏Â¶àÂ¶à‰∏∫‰ªÄ‰πàÁªôÂ•πËµ∑Ëøô‰∏™ÂêçÂ≠óÔºü(ÊÄùËÄÉ)", keywords: ["ÊÄùËÄÉ"] },
                { id: "rcC_2", text: "Â•πÂ∏∏Â∏∏ÊÄùËÄÉ‰ªÄ‰πàÈóÆÈ¢òÔºü(ÂêÑÁßçÂêÑÊ†∑, ÊØîÂ¶Ç)", keywords: ["ÂêÑÁßçÂêÑÊ†∑", "ÊØîÂ¶Ç"] },
                { id: "rcC_3", text: "Â•πÂ≠¶‰ªÄ‰πà‰∏ì‰∏öÔºü‰∏∫‰ªÄ‰πàÔºü(ÊïôËÇ≤, Êù•Ëá™)", keywords: ["ÊïôËÇ≤", "Êù•Ëá™"] },
                { id: "rcC_4", text: "Â•πÊúâÂì™‰∫õËÆ°ÂàíÔºü(Â§ö, Â∞ÜÊù•)", keywords: ["Â§ö", "Â∞ÜÊù•"] },
                { id: "rcC_5", text: "Â•πËßâÂæóÂÅö‰ªÄ‰πà‰∫ãÊÉÖÂæàÊúâÊÑèÊÄùÔºü(Âíå‚Ä¶Êâì‰∫§ÈÅì)", keywords: ["Âíå‚Ä¶Êâì‰∫§ÈÅì"] }
            ]
        };

        const sentenceCreationWords_B1 = [
            { hanzi: 'Êô∫ÊÖß', pinyin: 'zh√¨hu√¨', meaning: 'tr√≠ tu·ªá / wisdom' }, { hanzi: 'Êù•Ëá™', pinyin: 'l√°iz√¨', meaning: 'ƒë·∫øn t·ª´ / come from' },
            { hanzi: 'ËÆ°Âàí', pinyin: 'j√¨hu√†', meaning: 'k·∫ø ho·∫°ch / plan' }, { hanzi: 'ÈÄöËøá', pinyin: 't≈çnggu√≤', meaning: 'th√¥ng qua, v∆∞·ª£t qua / pass' },
            { hanzi: 'ÊµÅÂà©', pinyin: 'li√∫l√¨', meaning: 'l∆∞u lo√°t / fluent' }, { hanzi: '‰ºòÁßÄ', pinyin: 'y≈çuxi√π', meaning: '∆∞u t√∫, xu·∫•t s·∫Øc / excellent' },
            { hanzi: 'ÊÄùËÄÉ', pinyin: 'sƒ´k«éo', meaning: 'suy nghƒ©, t∆∞ duy / think' }, { hanzi: 'ÊØîÂ¶Ç', pinyin: 'b«êr√∫', meaning: 'v√≠ d·ª• / for example' },
            { hanzi: 'Êâì‰∫§ÈÅì', pinyin: 'd«é jiƒÅodao', meaning: 'giao ti·∫øp, ti·∫øp x√∫c / have dealings with' }, { hanzi: 'ÂØÜÂàá', pinyin: 'm√¨qi√®', meaning: 'm·∫≠t thi·∫øt, th√¢n thi·∫øt / close' }
        ];

        const paragraphWritingData_B1 = {
            title: "Ëá™Êàë‰ªãÁªç (T·ª± gi·ªõi thi·ªáu)",
            instructions: "D·ª±a theo c·∫•u tr√∫c \"‰ªªÂä°‰∏Ä Ëá™Êàë‰ªãÁªç\" (PDF trang 12)\nH√£y vi·∫øt m·ªôt ƒëo·∫°n vƒÉn gi·ªõi thi·ªáu b·∫£n th√¢n b·∫±ng ti·∫øng Trung, bao g·ªìm c√°c n·ªôi dung sau:\n1. T√™n c·ªßa b·∫°n.\n2. T·∫°i sao b·∫°n c√≥ t√™n ƒë√≥? (C√≥ th·ªÉ t·ª± s√°ng t·∫°o n·∫øu kh√¥ng c√≥ c√¢u chuy·ªán ƒë·∫∑c bi·ªát)\n3. Chuy√™n ng√†nh c·ªßa b·∫°n l√† g√¨? (Ho·∫∑c m√¥n h·ªçc b·∫°n y√™u th√≠ch n·∫øu ch∆∞a c√≥ chuy√™n ng√†nh)\n4. T·∫°i sao b·∫°n h·ªçc chuy√™n ng√†nh/m√¥n h·ªçc ƒë√≥?\n5. B·∫°n c√≥ nh·ªØng k·∫ø ho·∫°ch h·ªçc t·∫≠p n√†o?",
            structureHint: "C·∫•u tr√∫c g·ª£i √Ω sau:\nÂ§ßÂÆ∂Â•ΩÔºåÊàëÂè´ [ƒêi·ªÅn t√™n c·ªßa b·∫°n]„ÄÇ\nÊàë‰∏∫‰ªÄ‰πàÂè´Ëøô‰∏™ÂêçÂ≠óÂë¢Ôºü [Gi·∫£i th√≠ch √Ω nghƒ©a t√™n c·ªßa b·∫°n ho·∫∑c l√Ω do c√≥ t√™n ƒë√≥]„ÄÇ\nÊàëÁöÑ‰∏ì‰∏öÊòØ [ƒêi·ªÅn chuy√™n ng√†nh c·ªßa b·∫°n]„ÄÇ (Ho·∫∑c: ÊàëÂñúÊ¨¢ÁöÑÁßëÁõÆÊòØ...)\nÊàë‰∏∫‰ªÄ‰πàÂ≠¶‰π†Ëøô‰∏™‰∏ì‰∏öÂë¢Ôºü (Ho·∫∑c: Êàë‰∏∫‰ªÄ‰πàÂñúÊ¨¢Ëøô‰∏™ÁßëÁõÆÂë¢Ôºü) [Gi·∫£i th√≠ch l√Ω do]„ÄÇ\nÊàëÊúâÂæàÂ§öÂ≠¶‰π†ËÆ°ÂàíÔºåÊØîÂ¶ÇÔºö[N√™u m·ªôt v√†i k·∫ø ho·∫°ch h·ªçc t·∫≠p, v√≠ d·ª•: ÊàëÊâìÁÆóÊØèÂ§©ÁªÉ‰π†Ê±âËØ≠Âè£ËØ≠Âçä‰∏™Â∞èÊó∂ÔºåÂ∏åÊúõ‰∏ÄÂπ¥‰ª•ÂêéËÉΩÈÄöËøáHSK4Á∫ßËÄÉËØï„ÄÇÊàëËøòÊÉ≥Â§öÁúã‰∏≠ÂõΩÁîµÂΩ±Ôºå‰∫ÜËß£‰∏≠ÂõΩÊñáÂåñ„ÄÇ]„ÄÇ",
            vocabHint: "T·ª´ v·ª±ng c√≥ th·ªÉ s·ª≠ d·ª•ng (tham kh·∫£o PDF trang 13 ):\nÂßìÂêç: Êô∫ÊÖß, ÊÄùËÄÉ, ÂèëÈü≥ÂÉè...\n‰∏ì‰∏ö: ËØó(Ê≠å), Âì≤Â≠¶, ÊïôËÇ≤, Êâì‰∫§ÈÅì, ËÅîÁ≥ª, ÂØÜÂàá, ÊñáÂ≠¶, ÂõΩÈôÖÂÖ≥Á≥ª, ÂõΩÈôÖÁªèÊµé, ÈáëËûçË¥∏Êòì, ËÆ°ÁÆóÊú∫\nËÆ°Âàí: Â∞ÜÊù•, ËÆ°Âàí, ÈÄöËøá, ÊµÅÂà©, ‰ºòÁßÄ, Êú¨Áßë, ÊØï‰∏ö, ÂÆû‰π†, Â§ñ‰∫§ÂÆò, ÁêÜÊÉ≥\nÂÖ∂‰ªñ: Êù•Ëá™, Á°ÆÂÆû, ÊØîÂ¶Ç"
        };

        // ----- BI·∫æN TR·∫†NG TH√ÅI GAME -----
        let currentStage = 0; let gameStages = []; let totalQuestionsInGame = 0;
        let startTime; let timerInterval;
        let gameResults = { correct: 0, incorrect: 0, errors: [], totalTime: '00:00' };
        let playerName = "";
        let currentVocabMatchingPairs = []; let currentFillSentenceIndex = 0; let currentSentenceCompletionIndex = 0; let currentReadingQuestionIndex = 0; let currentSentenceCreationWordIndex_B1 = 0;
        let currentTargetWordForSC_B1 = null;

        // ----- DOM ELEMENTS -----
        const getEl = (id) => document.getElementById(id);
        const timerEl = () => getEl('timer'); const instructionsEl = () => getEl('instructions'); const gameAreaEl = () => getEl('game-area'); const hintButtonEl = () => getEl('hint-button'); const hintTextEl = () => getEl('hint-text'); const feedbackSectionEl = () => getEl('feedback-section'); const feedbackTextEl = () => getEl('feedback-text'); const nextStageButtonEl = () => getEl('next-stage-button'); const skipStageButtonEl = () => getEl('skip-stage-button'); const summaryPageEl = () => getEl('summary-page'); const gameContainerEl = () => getEl('game-container');


        // ----- FUNCTIONS -----
        // --- Helper Functions (Shuffle, Timer, UI, Feedback, AI) ---
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
        function startTimer() { startTime = Date.now(); if(timerInterval) clearInterval(timerInterval); timerInterval = setInterval(updateTimer, 1000); updateTimer(); }
        function updateTimer() { const currentTimerEl = timerEl(); if (!currentTimerEl) { if (timerInterval) clearInterval(timerInterval); return; } const elapsedTime = Math.floor((Date.now() - startTime) / 1000); const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0'); const seconds = (elapsedTime % 60).toString().padStart(2, '0'); currentTimerEl.textContent = `${minutes}:${seconds}`; gameResults.totalTime = `${minutes}:${seconds}`; }
        function stopTimer() { if(timerInterval) clearInterval(timerInterval); timerInterval = null; }
        function setInstructions(htmlContentWithIcon) { const currentInstructionsEl = instructionsEl(); if (currentInstructionsEl) { currentInstructionsEl.innerHTML = `<p><i>üíñ</i> ${htmlContentWithIcon}</p>`; } }
        function showFeedback(isCorrect, message) { const currentFeedbackSectionEl = feedbackSectionEl(); const currentFeedbackTextEl = feedbackTextEl(); if (!currentFeedbackSectionEl || !currentFeedbackTextEl) return; currentFeedbackTextEl.innerHTML = message; currentFeedbackSectionEl.className = ''; currentFeedbackSectionEl.classList.add(isCorrect ? 'correct' : 'incorrect'); currentFeedbackSectionEl.style.display = 'block'; }
        function recordResult(isCorrect, stageName, input, issue) { if (isCorrect) { gameResults.correct++; } else { gameResults.incorrect++; gameResults.errors.push({ stage: stageName, input: input || 'N/A', issue }); } console.log("Game Results Updated:", JSON.stringify(gameResults)); }
        function clearFeedback() { const currentFeedbackSectionEl = feedbackSectionEl(); const currentFeedbackTextEl = feedbackTextEl(); if (!currentFeedbackSectionEl || !currentFeedbackTextEl) return; currentFeedbackTextEl.textContent = ''; currentFeedbackSectionEl.style.display = 'none'; currentFeedbackSectionEl.className = ''; }
        async function showHint() { const currentHintTextEl = hintTextEl(); const currentHintButtonEl = hintButtonEl(); if (!currentHintTextEl || !currentHintButtonEl) return; currentHintButtonEl.disabled = true; currentHintTextEl.textContent = "üß† AI ƒëang t·∫°o g·ª£i √Ω..."; let hint = "Ch·ª©c nƒÉng g·ª£i √Ω ch∆∞a s·∫µn s√†ng cho m√†n n√†y."; const currentStageLoader = gameStages[currentStage-1]; if (currentStageLoader) { const stageName = currentStageLoader.name; if (stageName === 'loadSentenceCreationStage_B1' && currentTargetWordForSC_B1) { hint = `H√£y th·ª≠ ƒë·∫∑t m·ªôt c√¢u ho√†n ch·ªânh v·ªõi t·ª´ "${currentTargetWordForSC_B1.hanzi}" (${currentTargetWordForSC_B1.pinyin}) c√≥ nghƒ©a l√† "${currentTargetWordForSC_B1.meaning}".`;} else if (stageName === 'loadVocabFillStage_B1_Set1' || stageName === 'loadVocabFillStage_B1_Set2') { hint = "Ch·ªçn t·ª´ b·∫°n cho l√† ƒë√∫ng nh·∫•t v·ªõi ng·ªØ c·∫£nh c√¢u."; } } currentHintTextEl.textContent = hint; currentHintButtonEl.disabled = false; }
        function clearHint() { const currentHintTextEl = hintTextEl(); if (currentHintTextEl) currentHintTextEl.textContent = ''; }

        async function callAI(prompt) {
            const currentFeedbackEl = feedbackTextEl(); const currentFeedbackSectionEl = feedbackSectionEl();
            let purpose = "AI Check";
            if (prompt.includes("t·∫°o m·ªôt g·ª£i √Ω")) { purpose = "Generate Hint"; }

            console.log(`--- Calling AI (Gemini Flash) for ${purpose} ---`); console.log(prompt);
            if (!currentFeedbackEl || !currentFeedbackSectionEl) { console.error("Feedback elements not found!"); return { isCorrect: false, explanation: "L·ªói giao di·ªán." }; }

            if (purpose !== 'Generate Hint') { currentFeedbackEl.textContent = "üß† AI ƒëang suy nghƒ©..."; currentFeedbackSectionEl.className = ''; currentFeedbackSectionEl.classList.add('info'); currentFeedbackSectionEl.style.display = 'block'; }
            else { hintTextEl().textContent = "üß† AI ƒëang t·∫°o g·ª£i √Ω..."; }

            const apiKey = 'AIzaSyA7JKJYFmL8L05PDzoekqlu40A_BTWgrkE';

            const modelName = 'gemini-1.5-flash-latest';
            const apiEndpoint = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
            const generationConfig = { temperature: 0.3, maxOutputTokens: 600 };
            const safetySettings = [ { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" }, { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }, ];

            try {
                const response = await fetch(apiEndpoint, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ contents: [{ parts: [{ "text": prompt }] }], generationConfig: generationConfig, safetySettings: safetySettings }), });
                if (!response.ok) { let errorData; try { errorData = await response.json(); } catch (e) { errorData = { error: { message: await response.text() || 'Unknown API error' } }; } throw new Error(`API Error ${response.status}: ${errorData?.error?.message || response.statusText}`); }
                const data = await response.json();
                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content || !data.candidates[0].content.parts || data.candidates[0].content.parts.length === 0) {
                    let blockReason = data?.promptFeedback?.blockReason || 'No candidate parts in response.';
                    if (data?.candidates && data.candidates[0]?.finishReason && data.candidates[0].finishReason !== "STOP") {
                        blockReason += ` Finish Reason: ${data.candidates[0].finishReason}.`;
                    }
                    throw new Error(`AI response blocked or empty. Reason: ${blockReason}`);
                }
                const aiTextResponse = data.candidates[0].content.parts[0].text;
                console.log("AI Raw Response:", aiTextResponse);

                if (purpose === 'Generate Hint') { return { explanation: aiTextResponse }; }
                else {
                    let lowerResponse = aiTextResponse.toLowerCase(); let isCorrect = false;
                    if (lowerResponse.startsWith("ƒë√°nh gi√°: ƒë√∫ng") || lowerResponse.startsWith("ƒë√°nh gi√°: ƒë√∫ng.")) { isCorrect = true; }
                    else if (lowerResponse.startsWith("ƒë√°nh gi√° t·ªïng th·ªÉ: ƒë√∫ng")) { isCorrect = true; }

                    let explanation = aiTextResponse;
                    if (isCorrect) {
                        const nh·∫≠nX√©tMarker = "nh·∫≠n x√©t:";
                        const nh·∫≠nX√©tIndex = lowerResponse.indexOf(nh·∫≠nX√©tMarker);
                        if (nh·∫≠nX√©tIndex !== -1) {
                            explanation = "ƒê√°nh gi√°: ƒê√∫ng. " + aiTextResponse.substring(nh·∫≠nX√©tIndex + nh·∫≠nX√©tMarker.length).trim();
                        } else if (!lowerResponse.startsWith("ƒë√°nh gi√°: ƒë√∫ng")) {
                             explanation = "ƒê√°nh gi√°: ƒê√∫ng. " + aiTextResponse;
                        }
                    }
                    return { isCorrect, explanation };
                }
            } catch (error) {
                console.error(`Error calling ${modelName} API for ${purpose}:`, error);
                let errorMessage = "L·ªói khi g·ªçi AI. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c b·ªè qua.";
                if (error.message.includes("API Key not valid")) {
                    errorMessage = "L·ªói: API Key kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i API Key.";
                } else if (error.message.includes("API Error 429")) {
                    errorMessage = "L·ªói: V∆∞·ª£t qu√° gi·ªõi h·∫°n y√™u c·∫ßu t·ªõi AI. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t.";
                } else if (error.message.includes("AI response blocked")) {
                    errorMessage = "L·ªói: Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n ho·∫∑c n·ªôi dung kh√¥ng ph√π h·ª£p. Chi ti·∫øt: " + error.message;
                }

                if (purpose === 'Generate Hint') { hintTextEl().textContent = errorMessage; hintButtonEl().disabled = false; return { explanation: errorMessage }; }
                else { currentFeedbackEl.textContent = errorMessage; currentFeedbackSectionEl.className = ''; currentFeedbackSectionEl.classList.add('incorrect'); currentFeedbackSectionEl.style.display = 'block'; throw error; }
            }
        }

        // ----- STAGE LOADING AND CHECKING FUNCTIONS (B√ÄI 1) -----
        function loadVocabMatchingStage_B1() {
            setInstructions("ü§ù M√†n 1.1: N·ªëi T·ª´. K√©o t·ª´ ti·∫øng Trung (H√°n t·ª± & Pinyin) v√†o √¥ nghƒ©a ti·∫øng Vi·ªát t∆∞∆°ng ·ª©ng.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');

            const words = vocabMatchingData_B1.map(item => ({ id: item.id, text: `${item.hanzi} (${item.pinyin})`}));
            const meanings = vocabMatchingData_B1.map(item => ({ id: item.id, text: item.meaning }));
            shuffleArray(words);
            shuffleArray(meanings);

            let wordHTML = words.map(w => `<div class="draggable-item" draggable="true" data-id="${w.id}">${w.text}</div>`).join('');
            let meaningHTML = meanings.map(m => `<div class="drop-target" data-target-id="${m.id}"><span class="meaning-text">${m.text}</span></div>`).join('');

            gameArea.innerHTML = `
                <h3 class="stage-title">B√†i 1.1: N·ªëi T·ª´ V·ªõi Pinyin v√† Nghƒ©a</h3>
                <div id="vocab-matching-area">
                    <div class="vocab-list-column" id="drag-source-column">${wordHTML}</div>
                    <div class="meaning-list-column" id="drop-target-column">${meaningHTML}</div>
                </div>
                <button id="check-matching-b1">Ki·ªÉm Tra N·ªëi T·ª´</button>
            `;
            addDragDropListeners_B1();
            getEl('check-matching-b1').addEventListener('click', checkVocabMatching_B1);
        }

        function addDragDropListeners_B1() {
            const draggables = document.querySelectorAll('.draggable-item');
            const targets = document.querySelectorAll('.drop-target');
            let draggedItem = null;

            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', (e) => {
                    draggedItem = draggable;
                    e.dataTransfer.setData('text/plain', draggable.dataset.id);
                    setTimeout(() => draggable.style.opacity = '0.5', 0);
                });
                draggable.addEventListener('dragend', () => {
                    setTimeout(() => {
                        draggable.style.opacity = '1';
                        draggedItem = null;
                    }, 0);
                });
            });

            targets.forEach(target => {
                target.addEventListener('dragover', (e) => { e.preventDefault(); target.classList.add('over'); });
                target.addEventListener('dragleave', () => { target.classList.remove('over'); });
                target.addEventListener('drop', (e) => {
                    e.preventDefault();
                    target.classList.remove('over');
                    if (draggedItem && !target.querySelector('.draggable-item')) {
                        target.appendChild(draggedItem);
                    } else if (draggedItem) {
                        console.log("Target already has an item or no dragged item.");
                    }
                });
            });
        }

        function checkVocabMatching_B1() {
            let correctMatches = 0;
            const targets = document.querySelectorAll('.drop-target');
            targets.forEach(target => {
                const droppedWordEl = target.querySelector('.draggable-item');
                target.classList.remove('dropped-correct', 'incorrect-drop');
                if (droppedWordEl) {
                    const wordId = droppedWordEl.dataset.id;
                    const targetId = target.dataset.targetId;
                    if (wordId === targetId) {
                        correctMatches++;
                        target.classList.add('dropped-correct');
                         const wordInside = target.querySelector('.draggable-item');
                         if(wordInside) wordInside.draggable = false;
                    } else {
                        target.classList.add('incorrect-drop');
                    }
                }
            });
            if(gameStages[currentStage-1]?.name === "loadVocabMatchingStage_B1" && !getEl('check-matching-b1').dataset.counted) {
                totalQuestionsInGame += vocabMatchingData_B1.length;
                getEl('check-matching-b1').dataset.counted = 'true';
            }
            recordResult(correctMatches === vocabMatchingData_B1.length, "B√†i 1.1 N·ªëi t·ª´", `ƒê√∫ng ${correctMatches}/${vocabMatchingData_B1.length}`, correctMatches === vocabMatchingData_B1.length ? "" : "M·ªôt s·ªë c·∫∑p n·ªëi ch∆∞a ƒë√∫ng.");
            showFeedback(correctMatches === vocabMatchingData_B1.length, `B·∫°n ƒë√£ n·ªëi ƒë√∫ng ${correctMatches} / ${vocabMatchingData_B1.length} c·∫∑p.`);
            if (correctMatches === vocabMatchingData_B1.length) {
                nextStageButtonEl()?.classList.remove('hidden');
                getEl('check-matching-b1').disabled = true;
                const sourceColumn = getEl('drag-source-column');
                if (sourceColumn) sourceColumn.innerHTML = "<p style='color:grey; text-align:center;'>ƒê√£ ho√†n th√†nh!</p>";
            }
        }

        function loadVocabFillStage_B1_Set1() {
            setInstructions("‚úçÔ∏è M√†n 1.2 (Set 1): Ch·ªçn T·ª´. Ch·ªçn t·ª´ th√≠ch h·ª£p t·ª´ danh s√°ch ƒë·ªÉ ƒëi·ªÅn v√†o ch·ªó tr·ªëng.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');

            let sentencesHTML = vocabFillData_B1_Set1.sentences.map((sentenceData, index) => {
                let sentenceHTML = `<div class="fill-sentence" id="vf1_sentence_${index + 1}"><span>${index + 1}. </span>`;
                sentenceData.parts.forEach(part => {
                    if (typeof part === 'string') {
                        sentenceHTML += `<span>${part}</span>`;
                    } else {
                        sentenceHTML += `<select id="${part.placeholderID}">`;
                        sentenceHTML += `<option value="">---Ch·ªçn---</option>`;
                        vocabFillData_B1_Set1.options.forEach(opt => {
                            sentenceHTML += `<option value="${opt}">${opt}</option>`;
                        });
                        sentenceHTML += `</select>`;
                    }
                });
                sentenceHTML += `</div>`;
                return sentenceHTML;
            }).join('');

            gameArea.innerHTML = `
                <h3 class="stage-title">B√†i 1.2: Ch·ªçn T·ª´ (Set 1)</h3>
                <p style="font-style:italic;"><strong>T·ª´ ƒë·ªÉ ch·ªçn:</strong> ${vocabFillData_B1_Set1.options.join(' ‚Ä¢ ')}</p>
                ${sentencesHTML}
                <button id="check-vocab-fill-s1">Ki·ªÉm Tra ƒêi·ªÅn T·ª´ (Set 1)</button>
            `;
            getEl('check-vocab-fill-s1').addEventListener('click', () => checkVocabFill_B1(vocabFillData_B1_Set1, "check-vocab-fill-s1", "B√†i 1.2 Set 1"));
        }

        function loadVocabFillStage_B1_Set2() {
            setInstructions("‚úçÔ∏è M√†n 1.2 (Set 2): Ch·ªçn T·ª´. Ch·ªçn t·ª´ th√≠ch h·ª£p t·ª´ danh s√°ch ƒë·ªÉ ƒëi·ªÅn v√†o ch·ªó tr·ªëng.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');

            let sentencesHTML = vocabFillData_B1_Set2.sentences.map((sentenceData, index) => {
                let sentenceHTML = `<div class="fill-sentence" id="vf2_sentence_${index + 1}"><span>${index + 3}. </span>`;
                sentenceData.parts.forEach(part => {
                    if (typeof part === 'string') {
                        sentenceHTML += `<span>${part}</span>`;
                    } else {
                        sentenceHTML += `<select id="${part.placeholderID}">`;
                        sentenceHTML += `<option value="">---Ch·ªçn---</option>`;
                        vocabFillData_B1_Set2.options.forEach(opt => {
                            sentenceHTML += `<option value="${opt}">${opt}</option>`;
                        });
                        sentenceHTML += `</select>`;
                    }
                });
                sentenceHTML += `</div>`;
                return sentenceHTML;
            }).join('');

            gameArea.innerHTML = `
                <h3 class="stage-title">B√†i 1.2: Ch·ªçn T·ª´ (Set 2)</h3>
                <p style="font-style:italic;"><strong>T·ª´ ƒë·ªÉ ch·ªçn:</strong> ${vocabFillData_B1_Set2.options.join(' ‚Ä¢ ')}</p>
                ${sentencesHTML}
                <button id="check-vocab-fill-s2">Ki·ªÉm Tra ƒêi·ªÅn T·ª´ (Set 2)</button>
            `;
            getEl('check-vocab-fill-s2').addEventListener('click', () => checkVocabFill_B1(vocabFillData_B1_Set2, "check-vocab-fill-s2", "B√†i 1.2 Set 2"));
        }

        function checkVocabFill_B1(dataObject, buttonId, stageIdentifier) {
            let correctCount = 0;
            let totalBlanksInThisSet = 0;
            const feedbackMessages = [];
            dataObject.sentences.forEach((sentenceData, sentenceIndex) => {
                sentenceData.parts.forEach(part => {
                    if (typeof part !== 'string') {
                        totalBlanksInThisSet++;
                        const selectEl = getEl(part.placeholderID);
                        if (selectEl) {
                             const selectedValue = selectEl.value;
                             if (selectedValue === part.answer) {
                                 correctCount++;
                                 selectEl.style.borderColor = 'green';
                             } else {
                                 selectEl.style.borderColor = 'red';
                                 feedbackMessages.push(`C√¢u ${sentenceIndex + 1} (trong set), ch·ªó tr·ªëng "${part.answer}" ch·ªçn sai.`);
                             }
                        } else {
                             console.error("Kh√¥ng t√¨m th·∫•y select element:", part.placeholderID);
                        }
                    }
                });
            });

            const checkButton = getEl(buttonId);
            if(checkButton && !checkButton.dataset.counted) {
                totalQuestionsInGame += totalBlanksInThisSet;
                checkButton.dataset.counted = 'true';
            }

            recordResult(correctCount === totalBlanksInThisSet, stageIdentifier, `ƒê√∫ng ${correctCount}/${totalBlanksInThisSet}`, correctCount === totalBlanksInThisSet ? "" : feedbackMessages.join(" "));
            showFeedback(correctCount === totalBlanksInThisSet, `B·∫°n ƒë√£ ƒëi·ªÅn ƒë√∫ng ${correctCount} / ${totalBlanksInThisSet} ch·ªó tr·ªëng. ${correctCount !== totalBlanksInThisSet ? 'H√£y xem l·∫°i c√°c ch·ªó b√¥i ƒë·ªè.' : ''}`);
            if (correctCount === totalBlanksInThisSet) {
                nextStageButtonEl()?.classList.remove('hidden');
                if(checkButton) checkButton.disabled = true;
            } else {
                if(checkButton) checkButton.disabled = false;
            }
        }

        function loadSentenceCompletionStage_B1() {
            setInstructions("üìù M√†n 2.1: Ho√†n Th√†nh C√¢u. Vi·∫øt ti·∫øp v√†o ch·ªó tr·ªëng ƒë·ªÉ t·∫°o th√†nh c√¢u ho√†n ch·ªânh, ƒë√∫ng ng·ªØ ph√°p v√† t·ª± nhi√™n.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');
            if(!gameArea.dataset.questionsCounted_sc_b1) {
                 totalQuestionsInGame += sentenceCompletionData_B1.length;
                 gameArea.dataset.questionsCounted_sc_b1 = 'true';
            }

            let itemsHTML = sentenceCompletionData_B1.map((item, index) => {
                 return `
                     <div class="sentence-completion-item">
                         <label for="scb1_input_${item.id}">
                             ${index + 1}. ${item.starter}
                             <input type="text" id="scb1_input_${item.id}" placeholder="Vi·∫øt ti·∫øp v√†o ƒë√¢y..." data-hint-text="${item.hint || ''}">
                             ${item.exampleSuffix || ''}
                         </label>
                     </div>`;
             }).join('');

            gameArea.innerHTML = `
                <h3 class="stage-title">B√†i 2.1: Ho√†n Th√†nh C√¢u</h3>
                ${itemsHTML}
                <button id="check-sc-b1">Ki·ªÉm Tra Ho√†n Th√†nh C√¢u</button>
            `;
            getEl('check-sc-b1').addEventListener('click', checkAllSentenceCompletions_B1);
        }
        async function checkAllSentenceCompletions_B1() {
             const submitButton = getEl('check-sc-b1');
             submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback();
             let allCorrectThisCheck = true; let stageFeedback = [];

             for (let i = 0; i < sentenceCompletionData_B1.length; i++) {
                 const item = sentenceCompletionData_B1[i];
                 const userInputEl = getEl(`scb1_input_${item.id}`);
                 const userInput = userInputEl.value.trim();
                 const fullSentenceAttempt = item.starter + userInput + (item.exampleSuffix || '');

                 if (!userInput) {
                     userInputEl.style.borderColor = 'red'; allCorrectThisCheck = false;
                     recordResult(false, `B√†i 2.1 C√¢u ${i+1}`, "Ch∆∞a nh·∫≠p", "Ch∆∞a ho√†n th√†nh c√¢u.");
                     stageFeedback.push(`C√¢u ${i+1}: B·∫°n ch∆∞a ho√†n th√†nh c√¢u.`);
                     userInputEl.placeholder = "Vui l√≤ng ƒëi·ªÅn v√†o ƒë√¢y!";
                 } else {
                     // UPDATED PROMPT for Sentence Completion
                     const prompt = `
                        B·∫°n l√† m·ªôt gi√°o vi√™n ti·∫øng Trung ƒëang ch·∫•m b√†i cho h·ªçc sinh.
                        Nhi·ªám v·ª•: H·ªçc sinh c·∫ßn ƒëi·ªÅn v√†o ch·ªó tr·ªëng ƒë·ªÉ ho√†n th√†nh c√¢u.
                        C√¢u cho s·∫µn c√≥ d·∫°ng: "${item.starter} ______ ${item.exampleSuffix || ''}"
                        Ph·∫ßn h·ªçc sinh ƒëi·ªÅn v√†o ch·ªó tr·ªëng (______): "${userInput}"
                        C√¢u ƒë·∫ßy ƒë·ªß m√† h·ªçc sinh t·∫°o ra l√†: "${fullSentenceAttempt}"

                        Y√™u c·∫ßu ƒë√°nh gi√° CH√çNH:
                        1.  **Ng·ªØ ph√°p:** Ph·∫ßn ƒëi·ªÅn ("${userInput}") c√≥ l√†m cho c√¢u ƒë·∫ßy ƒë·ªß ("${fullSentenceAttempt}") ƒë√∫ng ng·ªØ ph√°p ti·∫øng Trung kh√¥ng?
                        2.  **C√°ch d√πng t·ª´:** C√°ch d√πng t·ª´ trong ph·∫ßn ƒëi·ªÅn ("${userInput}") c√≥ ph√π h·ª£p v√† t·ª± nhi√™n khi gh√©p v·ªõi ph·∫ßn c√≤n l·∫°i c·ªßa c√¢u kh√¥ng?
                        3.  **Logic v√† t·ª± nhi√™n c·ªßa c√¢u ho√†n ch·ªânh:** C√¢u ƒë·∫ßy ƒë·ªß ("${fullSentenceAttempt}") c√≥ logic, √Ω nghƒ©a r√µ r√†ng v√† nghe t·ª± nhi√™n kh√¥ng?
                        L∆ØU √ù: KH√îNG c·∫ßn h·ªçc sinh ph·∫£i s·ª≠ d·ª•ng m·ªôt t·ª´ v·ª±ng c·ª• th·ªÉ n√†o ƒë√≥ t·ª´ g·ª£i √Ω (n·∫øu c√≥). Ch·ªâ c·∫ßn c√¢u ho√†n ch·ªânh ƒë√∫ng v√† t·ª± nhi√™n.

                        ƒê·ªãnh d·∫°ng tr·∫£ l·ªùi B·∫ÆT BU·ªòC:
                        ƒê√°nh gi√°: [ƒê√∫ng/Sai]
                        Nh·∫≠n x√©t: [N·∫øu Sai, gi·∫£i th√≠ch NG·∫ÆN G·ªåN l·ªói ng·ªØ ph√°p ho·∫∑c c√°ch d√πng t·ª´ trong ph·∫ßn "${userInput}" khi·∫øn c√¢u "${fullSentenceAttempt}" ch∆∞a ƒë√∫ng/ch∆∞a t·ª± nhi√™n, v√† g·ª£i √Ω c√°ch s·ª≠a NG·∫ÆN G·ªåN cho ph·∫ßn "${userInput}". N·∫øu ƒê√∫ng, ghi "C√¢u t·ªët, ng·ªØ ph√°p v√† c√°ch d√πng t·ª´ ph√π h·ª£p, t·ª± nhi√™n." ho·∫∑c khen t∆∞∆°ng t·ª±.]
                    `;
                     try {
                         const aiResult = await callAI(prompt);
                         recordResult(aiResult.isCorrect, `B√†i 2.1 C√¢u ${i+1}`, fullSentenceAttempt, aiResult.isCorrect ? "" : aiResult.explanation);
                         if (!aiResult.isCorrect) { allCorrectThisCheck = false; userInputEl.style.borderColor = 'red'; }
                         else { userInputEl.style.borderColor = 'green'; }
                         stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> ${aiResult.explanation.replace(/\n/g, '<br>')}`);
                     } catch (error) { allCorrectThisCheck = false; recordResult(false, `B√†i 2.1 C√¢u ${i+1}`, fullSentenceAttempt, `L·ªói API: ${error.message}`); stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> L·ªói khi ki·ªÉm tra v·ªõi AI.`); userInputEl.style.borderColor = 'orange'; }
                 }
             }
             showFeedback(allCorrectThisCheck, stageFeedback.join("<br><br>"));
             submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra Ho√†n Th√†nh C√¢u";
             if (allCorrectThisCheck) { nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true; }
        }

        function loadReadingCompStage_B1_A() {
            setInstructions("üìñ M√†n 3.A: ƒê·ªçc Hi·ªÉu. Tr·∫£ l·ªùi c√°c c√¢u h·ªèi sau.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');
            if(!gameArea.dataset.questionsCounted_rcA) { totalQuestionsInGame += readingCompData_B1_A.questions.length; gameArea.dataset.questionsCounted_rcA = 'true'; }

            let questionsHTML = readingCompData_B1_A.questions.map((q, index) => `
                <div class="reading-question">
                    <label for="rcA_input_${q.id}">${index + 1}. ${q.text}</label>
                    <textarea id="rcA_input_${q.id}" rows="3"></textarea>
                </div>
            `).join('');
            gameArea.innerHTML = `<h3 class="stage-title">${readingCompData_B1_A.title}</h3>${questionsHTML}<button id="check-rcA">Ki·ªÉm Tra</button>`;
            getEl('check-rcA').addEventListener('click', checkAllReadingComp_B1_A);
        }
        async function checkAllReadingComp_B1_A() {
             const submitButton = getEl('check-rcA'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback();
             let allCorrectThisCheck = true; let stageFeedback = [];
             for (let i = 0; i < readingCompData_B1_A.questions.length; i++) {
                 const q = readingCompData_B1_A.questions[i];
                 const userAnswer = getEl(`rcA_input_${q.id}`).value.trim();
                 if(!userAnswer) { allCorrectThisCheck = false; stageFeedback.push(`C√¢u ${i+1}: Ch∆∞a tr·∫£ l·ªùi.`); recordResult(false, `B√†i 3.A Q${i+1}`, "Ch∆∞a nh·∫≠p", "Ch∆∞a tr·∫£ l·ªùi"); getEl(`rcA_input_${q.id}`).style.borderColor = 'red'; continue;}
                 const prompt = `B·∫°n l√† gi√°o vi√™n ti·∫øng Trung. C√¢u h·ªèi l√†: "${q.text}". H·ªçc sinh tr·∫£ l·ªùi b·∫±ng ti·∫øng Trung: "${userAnswer}". C√¢u tr·∫£ l·ªùi c√≥ ph√π h·ª£p, logic v√† di·ªÖn ƒë·∫°t t·ªët kh√¥ng? Tr·∫£ l·ªùi THEO ƒê√öNG ƒê·ªäNH D·∫†NG: "ƒê√°nh gi√°: [ƒê√∫ng/Sai]\nNh·∫≠n x√©t: [Nh·∫≠n x√©t NG·∫ÆN G·ªåN, n·∫øu sai ƒë∆∞a ra g·ª£i √Ω s·ª≠a]".`;
                 try {
                     const aiResult = await callAI(prompt);
                     recordResult(aiResult.isCorrect, `B√†i 3.A Q${i+1}`, userAnswer, aiResult.isCorrect ? "" : aiResult.explanation);
                     if(!aiResult.isCorrect) allCorrectThisCheck = false;
                     getEl(`rcA_input_${q.id}`).style.borderColor = aiResult.isCorrect ? 'green' : 'red';
                     stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> ${aiResult.explanation.replace(/\n/g, '<br>')}`);
                 } catch (e) { allCorrectThisCheck = false; stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> L·ªói API.`); recordResult(false, `B√†i 3.A Q${i+1}`, userAnswer, `L·ªói API: ${e.message}`); getEl(`rcA_input_${q.id}`).style.borderColor = 'orange';}
             }
             showFeedback(allCorrectThisCheck, stageFeedback.join('<br><br>'));
             submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra";
             if(allCorrectThisCheck) {nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true;}
        }

        function loadReadingCompStage_B1_B() {
            setInstructions("üìñ M√†n 3.B: ƒê·ªçc Hi·ªÉu ËØæÊñá(‰∏Ä). ƒêi·ªÅn v√†o ch·ªó tr·ªëng d·ª±a v√†o b√†i ƒë·ªçc v√† t·ª´ kh√≥a.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');
            const questionsB = readingCompData_B1_B.questions.concat(readingCompData_B1_B.subQuestionsLearningPlan);
            if(!gameArea.dataset.questionsCounted_rcB) { totalQuestionsInGame += questionsB.length; gameArea.dataset.questionsCounted_rcB = 'true'; }

            let formattedPassage = readingCompData_B1_B.passage.split('\n').map(line => {
                if (line.startsWith("Âº†Â∞èËñá:")) return `<p class="dialogue-line"><strong class="speaker speaker-zhang">Âº†Â∞èËñá:</strong><span>${line.substring("Âº†Â∞èËñá:".length)}</span></p>`;
                if (line.startsWith("Êú¥Êô∫ÊÖß:")) return `<p class="dialogue-line"><strong class="speaker speaker-pu">Êú¥Êô∫ÊÖß:</strong><span>${line.substring("Êú¥Êô∫ÊÖß:".length)}</span></p>`;
                if (line.startsWith("Â±±‰∏ãÂíå‰πü:")) return `<p class="dialogue-line"><strong class="speaker speaker-shanxia">Â±±‰∏ãÂíå‰πü:</strong><span>${line.substring("Â±±‰∏ãÂíå‰πü:".length)}</span></p>`;
                if (line.startsWith("ÂÜØÂ∞öÂæ∑:")) return `<p class="dialogue-line"><strong class="speaker speaker-feng">ÂÜØÂ∞öÂæ∑:</strong><span>${line.substring("ÂÜØÂ∞öÂæ∑:".length)}</span></p>`;
                if (line.startsWith("ÈôàÊñ∞Èò≥:")) return `<p class="dialogue-line"><strong class="speaker speaker-chen">ÈôàÊñ∞Èò≥:</strong><span>${line.substring("ÈôàÊñ∞Èò≥:".length)}</span></p>`;
                if (line.startsWith("(")) return `<p class="reading-narrative">${line}</p>`;
                return `<p class="dialogue-line">${line}</p>`;
            }).join('');


            let questionsHTML = `<div class="reading-passage-container"><h4>ËØæÊñá(‰∏Ä)</h4>${formattedPassage}</div>`;

            questionsHTML += questionsB.map((q, index) => `
                <div class="reading-question">
                    <label for="rcB_input_${q.id}">
                        ${index + 1}. ${q.promptBefore}
                        <input type="text" id="rcB_input_${q.id}" placeholder="ƒêi·ªÅn v√†o ƒë√¢y..." style="width:50%;">
                        ${q.promptAfter || ''}
                    </label>
                </div>
            `).join('');
            gameArea.innerHTML = `<h3 class="stage-title">${readingCompData_B1_B.title}</h3>${questionsHTML}<button id="check-rcB">Ki·ªÉm Tra</button>`;
            getEl('check-rcB').addEventListener('click', checkAllReadingComp_B1_B);
        }
        async function checkAllReadingComp_B1_B() {
             const submitButton = getEl('check-rcB'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback();
             let allCorrectThisCheck = true; let stageFeedback = [];
             const questionsB = readingCompData_B1_B.questions.concat(readingCompData_B1_B.subQuestionsLearningPlan);

             for (let i = 0; i < questionsB.length; i++) {
                 const q = questionsB[i];
                 const userAnswer = getEl(`rcB_input_${q.id}`).value.trim();
                 if(!userAnswer) { allCorrectThisCheck = false; stageFeedback.push(`C√¢u ${i+1}: Ch∆∞a ƒëi·ªÅn.`); recordResult(false, `B√†i 3.B Q${i+1}`, "Ch∆∞a nh·∫≠p", "Ch∆∞a ƒëi·ªÅn"); getEl(`rcB_input_${q.id}`).style.borderColor = 'red'; continue; }
                 const questionText = `${q.promptBefore} [TR·∫¢ L·ªúI C·ª¶A H·ªåC SINH] ${q.promptAfter || ''}`;
                 const keywordsForAI = q.promptBefore.match(/\(([^)]+)\)/) ? q.promptBefore.match(/\(([^)]+)\)/)[1] : "Kh√¥ng c√≥";

                 const prompt = `B·∫°n l√† gi√°o vi√™n ti·∫øng Trung. D·ª±a v√†o ƒëo·∫°n vƒÉn ËØæÊñá(‰∏Ä): "${readingCompData_B1_B.passage}".\nY√™u c·∫ßu: Ho√†n th√†nh c√¢u sau "${q.promptBefore.replace(/\([^)]+\)/g, '______')}${q.promptAfter || ''}" d·ª±a v√†o n·ªôi dung b√†i ƒë·ªçc v√† s·ª≠ d·ª•ng c√°c t·ª´ kh√≥a g·ª£i √Ω: ${keywordsForAI}.\nH·ªçc sinh ƒëi·ªÅn v√†o ch·ªó tr·ªëng l√†: "${userAnswer}".\nPh·∫ßn ƒëi·ªÅn c·ªßa h·ªçc sinh c√≥ ƒë√∫ng v√† ph√π h·ª£p kh√¥ng? Tr·∫£ l·ªùi THEO ƒê√öNG ƒê·ªäNH D·∫†NG: "ƒê√°nh gi√°: [ƒê√∫ng/Sai]\nNh·∫≠n x√©t: [Gi·∫£i th√≠ch NG·∫ÆN G·ªåN, n·∫øu sai g·ª£i √Ω s·ª≠a]".`;
                 try {
                     const aiResult = await callAI(prompt);
                     recordResult(aiResult.isCorrect, `B√†i 3.B Q${i+1}`, userAnswer, aiResult.isCorrect ? "" : aiResult.explanation);
                     if(!aiResult.isCorrect) allCorrectThisCheck = false;
                     getEl(`rcB_input_${q.id}`).style.borderColor = aiResult.isCorrect ? 'green' : 'red';
                     stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> ${aiResult.explanation.replace(/\n/g, '<br>')}`);
                 } catch (e) { allCorrectThisCheck = false; stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> L·ªói API.`); recordResult(false, `B√†i 3.B Q${i+1}`, userAnswer, `L·ªói API: ${e.message}`); getEl(`rcB_input_${q.id}`).style.borderColor = 'orange';}
             }
             showFeedback(allCorrectThisCheck, stageFeedback.join('<br><br>'));
             submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra";
             if(allCorrectThisCheck) {nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true;}
        }

        function loadReadingCompStage_B1_C() {
            setInstructions("üìñ M√†n 3.C: ƒê·ªçc Hi·ªÉu Áü≠Êñá(‰∏Ä). ƒê·ªçc ƒëo·∫°n vƒÉn v√† tr·∫£ l·ªùi c√¢u h·ªèi.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');
            if(!gameArea.dataset.questionsCounted_rcC) { totalQuestionsInGame += readingCompData_B1_C.questions.length; gameArea.dataset.questionsCounted_rcC = 'true'; }

            let questionsHTML = `<div class="reading-passage-container"><h4>Áü≠Êñá(‰∏Ä)</h4><p style="font-style:italic; color:grey;">(N·ªôi dung b√†i ƒë·ªçc)</p>${readingCompData_B1_C.passage.replace(/\n/g, '<br>')}</div>`;
            questionsHTML += readingCompData_B1_C.questions.map((q, index) => `
                <div class="reading-question">
                    <label for="rcC_input_${q.id}">${index + 1}. ${q.text}</label>
                    <textarea id="rcC_input_${q.id}" rows="3"></textarea>
                </div>
            `).join('');
            gameArea.innerHTML = `<h3 class="stage-title">${readingCompData_B1_C.title}</h3>${questionsHTML}<button id="check-rcC">Ki·ªÉm Tra</button>`;
            getEl('check-rcC').addEventListener('click', checkAllReadingComp_B1_C);
        }
        async function checkAllReadingComp_B1_C() {
             const submitButton = getEl('check-rcC'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback();
             let allCorrectThisCheck = true; let stageFeedback = [];
             for (let i = 0; i < readingCompData_B1_C.questions.length; i++) {
                 const q = readingCompData_B1_C.questions[i];
                 const userAnswer = getEl(`rcC_input_${q.id}`).value.trim();
                 if(!userAnswer) { allCorrectThisCheck = false; stageFeedback.push(`C√¢u ${i+1}: Ch∆∞a tr·∫£ l·ªùi.`); recordResult(false, `B√†i 3.C Q${i+1}`, "Ch∆∞a nh·∫≠p", "Ch∆∞a tr·∫£ l·ªùi"); getEl(`rcC_input_${q.id}`).style.borderColor = 'red'; continue; }
                 const prompt = `B·∫°n l√† gi√°o vi√™n ti·∫øng Trung. D·ª±a v√†o ƒëo·∫°n vƒÉn Áü≠Êñá(‰∏Ä): "${readingCompData_B1_C.passage}".\nC√¢u h·ªèi l√†: "${q.text}". Y√™u c·∫ßu h·ªçc sinh tr·∫£ l·ªùi b·∫±ng ti·∫øng Trung v√† s·ª≠ d·ª•ng c√°c t·ª´ kh√≥a g·ª£i √Ω: ${q.keywords.join(', ')}.\nH·ªçc sinh tr·∫£ l·ªùi: "${userAnswer}".\nC√¢u tr·∫£ l·ªùi c√≥ ƒë√∫ng, d·ª±a tr√™n n·ªôi dung ƒëo·∫°n vƒÉn v√† c√≥ s·ª≠ d·ª•ng ƒë√∫ng c√°c t·ª´ kh√≥a ƒë∆∞·ª£c y√™u c·∫ßu kh√¥ng? Tr·∫£ l·ªùi THEO ƒê√öNG ƒê·ªäNH D·∫†NG: "ƒê√°nh gi√°: [ƒê√∫ng/Sai]\nNh·∫≠n x√©t: [Gi·∫£i th√≠ch NG·∫ÆN G·ªåN, n·∫øu sai g·ª£i √Ω s·ª≠a]".`;
                 try {
                     const aiResult = await callAI(prompt);
                     recordResult(aiResult.isCorrect, `B√†i 3.C Q${i+1}`, userAnswer, aiResult.isCorrect ? "" : aiResult.explanation);
                     if(!aiResult.isCorrect) allCorrectThisCheck = false;
                     getEl(`rcC_input_${q.id}`).style.borderColor = aiResult.isCorrect ? 'green' : 'red';
                     stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> ${aiResult.explanation.replace(/\n/g, '<br>')}`);
                 } catch (e) { allCorrectThisCheck = false; stageFeedback.push(`<strong>C√¢u ${i+1}:</strong> L·ªói API.`); recordResult(false, `B√†i 3.C Q${i+1}`, userAnswer, `L·ªói API: ${e.message}`); getEl(`rcC_input_${q.id}`).style.borderColor = 'orange';}
             }
             showFeedback(allCorrectThisCheck, stageFeedback.join('<br><br>'));
             submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra";
             if(allCorrectThisCheck) {nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true;}
        }

        function loadSentenceCreationStage_B1() {
            setInstructions("üí¨ M√†n 4.1: ƒê·∫∑t C√¢u. H√£y ƒë·∫∑t m·ªôt c√¢u ti·∫øng Trung ho√†n ch·ªânh s·ª≠ d·ª•ng t·ª´ cho s·∫µn.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.remove('hidden');
            currentSentenceCreationWordIndex_B1 = 0;
            displayCurrentSCWord_B1();
        }
        function displayCurrentSCWord_B1() {
            const gameArea = gameAreaEl();
            if (sentenceCreationWords_B1 && currentSentenceCreationWordIndex_B1 < sentenceCreationWords_B1.length) {
                currentTargetWordForSC_B1 = sentenceCreationWords_B1[currentSentenceCreationWordIndex_B1];
                gameArea.innerHTML = ` <h3 class="stage-title">B√†i 4.1: ƒê·∫∑t C√¢u (${currentSentenceCreationWordIndex_B1 + 1}/${sentenceCreationWords_B1.length})</h3> <div id="sc-current-word-area"> <p><strong>H√£y ƒë·∫∑t c√¢u v·ªõi t·ª´:</strong></p> <span id="sc-current-word-hanzi">${currentTargetWordForSC_B1.hanzi}</span> <span id="sc-current-word-pinyin">(${currentTargetWordForSC_B1.pinyin})</span> <span id="sc-current-word-meaning">${currentTargetWordForSC_B1.meaning}</span> </div> <textarea id="sc-sentence-input" rows="4" placeholder="Vi·∫øt c√¢u c·ªßa b·∫°n v√†o ƒë√¢y..."></textarea> <button id="submit-sc-sentence-b1">Ki·ªÉm Tra C√¢u</button> `;
                getEl('submit-sc-sentence-b1').addEventListener('click', handleSubmitSCCurrentSentence_B1);
                clearFeedback(); clearHint(); nextStageButtonEl()?.classList.add('hidden');
            } else {
                console.log("Ho√†n th√†nh M√†n 4.1 ƒê·∫∑t C√¢u.");
                loadNextStage();
            }
        }
        async function handleSubmitSCCurrentSentence_B1() {
            const sentenceInput = getEl('sc-sentence-input'); const sentence = sentenceInput ? sentenceInput.value.trim() : '';
            if (!currentTargetWordForSC_B1) { showFeedback(false, "L·ªói: Kh√¥ng c√≥ t·ª´ m·ª•c ti√™u."); return; }
            if (!sentence) { showFeedback(false, "B·∫°n ch∆∞a nh·∫≠p c√¢u!"); return; }
            const submitButton = getEl('submit-sc-sentence-b1'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ch·∫•m ƒëi·ªÉm..."; clearFeedback();
            const targetWordInfo = `${currentTargetWordForSC_B1.hanzi} (${currentTargetWordForSC_B1.pinyin}): ${currentTargetWordForSC_B1.meaning}`;
            // UPDATED PROMPT for Sentence Creation
            const prompt = `
                B·∫°n l√† m·ªôt gi√°o vi√™n ti·∫øng Trung.
                H·ªçc sinh ƒë∆∞·ª£c y√™u c·∫ßu ƒë·∫∑t m·ªôt c√¢u ho√†n ch·ªânh b·∫±ng ti·∫øng Trung s·ª≠ d·ª•ng t·ª´ sau: "${targetWordInfo}".
                C√¢u h·ªçc sinh ƒë·∫∑t l√†: "${sentence}".

                H√£y ƒë√°nh gi√° c√¢u c·ªßa h·ªçc sinh d·ª±a tr√™n c√°c ti√™u ch√≠ CH√çNH:
                1.  **S·ª≠ d·ª•ng t·ª´ kh√≥a:** C√¢u c√≥ s·ª≠ d·ª•ng ƒë√∫ng t·ª´ kh√≥a "${currentTargetWordForSC_B1.hanzi}" kh√¥ng?
                2.  **Ng·ªØ ph√°p:** C√¢u c√≥ ƒë√∫ng ng·ªØ ph√°p ti·∫øng Trung kh√¥ng?
                3.  **Logic v√† Ng·ªØ nghƒ©a:** C√¢u c√≥ logic, √Ω nghƒ©a r√µ r√†ng v√† ph√π h·ª£p kh√¥ng?
                4.  **ƒê·ªô t·ª± nhi√™n:** C√¢u c√≥ nghe t·ª± nhi√™n nh∆∞ ng∆∞·ªùi b·∫£n x·ª© n√≥i kh√¥ng?
                Quan tr·ªçng: KH√îNG t·∫≠p trung v√†o vi·ªác c√≥ theo m·ªôt "c√¢u g·ªëc" n√†o kh√¥ng, v√¨ ƒë√¢y l√† ƒë·∫∑t c√¢u t·ª± do v·ªõi t·ª´ cho s·∫µn.

                Tr·∫£ l·ªùi THEO ƒê√öNG ƒê·ªäNH D·∫†NG sau:
                ƒê√°nh gi√°: [ƒê√∫ng/Sai]
                Nh·∫≠n x√©t: [N·∫øu Sai, gi·∫£i th√≠ch NG·∫ÆN G·ªåN l·ªói sai ch√≠nh (v√≠ d·ª•: ch∆∞a d√πng t·ª´ kh√≥a, sai ng·ªØ ph√°p, kh√¥ng t·ª± nhi√™n) v√† ƒë∆∞a ra m·ªôt g·ª£i √Ω c·∫£i thi·ªán c√¢u NG·∫ÆN G·ªåN. N·∫øu ƒê√∫ng, ghi "C√¢u t·ªët, s·ª≠ d·ª•ng ƒë√∫ng t·ª´ v√† t·ª± nhi√™n." ho·∫∑c khen t∆∞∆°ng t·ª±.]
            `;
            try {
                const aiResult = await callAI(prompt);
                const currentWordKey = `sc_b1_${currentTargetWordForSC_B1.hanzi.replace(/\s/g, '_')}`;
                if (!gameAreaEl().dataset[currentWordKey]) {
                     totalQuestionsInGame++;
                     gameAreaEl().dataset[currentWordKey] = 'counted';
                }
                recordResult(aiResult.isCorrect, `B√†i 4.1 (T·ª´: ${currentTargetWordForSC_B1.hanzi})`, sentence, aiResult.isCorrect ? "" : aiResult.explanation);
                showFeedback(aiResult.isCorrect, aiResult.explanation.replace(/\n/g, '<br>'));
                if (aiResult.isCorrect) { currentSentenceCreationWordIndex_B1++; setTimeout(displayCurrentSCWord_B1, 2000); }
                else { submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra C√¢u"; }
            } catch (error) { showFeedback(false, `L·ªói API: ${error.message}`); submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra C√¢u"; }
        }

        function loadParagraphWritingStage_B1() {
            setInstructions("‚úçÔ∏è M√†n 5.1: Vi·∫øt ƒêo·∫°n VƒÉn. H√£y vi·∫øt m·ªôt b√†i t·ª± gi·ªõi thi·ªáu theo g·ª£i √Ω.");
            const gameArea = gameAreaEl();
            hintButtonEl()?.classList.add('hidden');
            if(!gameArea.dataset.questionsCounted_pw_b1) {totalQuestionsInGame++; gameArea.dataset.questionsCounted_pw_b1 = 'true';}

            gameArea.innerHTML = ` <h3 class="stage-title">B√†i 5.1: ${paragraphWritingData_B1.title}</h3> <div id="paragraph-writing-prompt"> <p>${paragraphWritingData_B1.instructions.replace(/\n/g, '<br>')}</p> <h4>C·∫•u tr√∫c g·ª£i √Ω:</h4> <p>${paragraphWritingData_B1.structureHint.replace(/\n/g, '<br>')}</p> <h4>T·ª´ v·ª±ng c√≥ th·ªÉ s·ª≠ d·ª•ng:</h4> <p>${paragraphWritingData_B1.vocabHint.replace(/\n/g, '<br>')}</p> </div> <textarea id="paragraph-input" placeholder="Vi·∫øt ƒëo·∫°n vƒÉn c·ªßa b·∫°n v√†o ƒë√¢y (kho·∫£ng 100-150 ch·ªØ)..."></textarea> <div id="char-count">0 ch·ªØ</div> <button id="check-paragraph-writing-b1">Ki·ªÉm Tra ƒêo·∫°n VƒÉn</button> `;
            const paragraphInputEl = getEl('paragraph-input'); const charCountEl = getEl('char-count');
            paragraphInputEl.addEventListener('input', () => { const charLength = paragraphInputEl.value.length; charCountEl.textContent = `${charLength} ch·ªØ`; if (charLength > 170 || charLength < 80 && charLength > 0) { charCountEl.style.color = 'red'; } else { charCountEl.style.color = '#6c757d'; } });
            getEl('check-paragraph-writing-b1').addEventListener('click', checkParagraphWriting_B1);
        }
        async function checkParagraphWriting_B1() {
            const paragraphInput = getEl('paragraph-input').value.trim();
            if (paragraphInput.length < 80) { showFeedback(false, "ƒêo·∫°n vƒÉn c·ªßa b·∫°n h∆°i ng·∫Øn, h√£y vi·∫øt th√™m nh√© (√≠t nh·∫•t 80 ch·ªØ)."); return; }
            const submitButton = getEl('check-paragraph-writing-b1'); submitButton.disabled = true; submitButton.textContent = "AI ƒëang ki·ªÉm tra..."; clearFeedback();
            const prompt = `B·∫°n l√† gi√°o vi√™n ti·∫øng Trung. ƒê√°nh gi√° ƒëo·∫°n vƒÉn t·ª± gi·ªõi thi·ªáu sau c·ªßa h·ªçc sinh (y√™u c·∫ßu kho·∫£ng 100-150 ch·ªØ b·∫±ng ti·∫øng Trung): "${paragraphInput}". Xem x√©t s·ª± m·∫°ch l·∫°c, ng·ªØ ph√°p, t·ª´ v·ª±ng (c√≥ s·ª≠ d·ª•ng t·ª´ g·ª£i √Ω kh√¥ng?), v√† m·ª©c ƒë·ªô ho√†n th√†nh y√™u c·∫ßu ƒë·ªÅ b√†i (t√™n, √Ω nghƒ©a t√™n, chuy√™n ng√†nh/m√¥n h·ªçc y√™u th√≠ch, l√Ω do, k·∫ø ho·∫°ch h·ªçc t·∫≠p). Tr·∫£ l·ªùi THEO ƒê√öNG ƒê·ªäNH D·∫†NG: "ƒê√°nh gi√°: [T·ªët/Kh√°/C·∫ßn c·∫£i thi·ªán]\nNh·∫≠n x√©t: [Nh·∫≠n x√©t t·ªïng quan v√† 2-3 g·ª£i √Ω c·∫£i thi·ªán NG·∫ÆN G·ªåN.]"`;
            try {
                const aiResult = await callAI(prompt);
                let isPass = !aiResult.explanation.toLowerCase().includes("c·∫ßn c·∫£i thi·ªán");
                recordResult(isPass, "B√†i 5.1 Vi·∫øt ƒëo·∫°n", paragraphInput.substring(0,50)+"...", isPass ? "" : aiResult.explanation);
                showFeedback(isPass, aiResult.explanation.replace(/\n/g, '<br>'));
                if (isPass) { nextStageButtonEl()?.classList.remove('hidden'); submitButton.disabled = true; }
                else { submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra ƒêo·∫°n VƒÉn"; }
            } catch (error) { showFeedback(false, `L·ªói API: ${error.message}`); submitButton.disabled = false; submitButton.textContent = "Ki·ªÉm Tra ƒêo·∫°n VƒÉn"; }
        }

        // ----- QU·∫¢N L√ù M√ÄN CH∆†I -----
        function loadNextStage() { // MOVED DEFINITION UP
            currentStage++;
            clearFeedback();
            clearHint();
            const nextBtn = nextStageButtonEl();
            const skipBtn = skipStageButtonEl();
            const hintBtn = hintButtonEl();

            if(nextBtn) nextBtn.classList.add('hidden');

            if (currentStage <= gameStages.length) {
                const stageLoaderFunction = gameStages[currentStage - 1];
                console.log(`Loading stage ${currentStage}: ${stageLoaderFunction.name}`);
                stageLoaderFunction();
                if(hintBtn) hintBtn.classList.remove('hidden');
                if(skipBtn) skipBtn.classList.remove('hidden');
            } else {
                console.log("All stages completed. Showing summary.");
                showSummary();
                if(hintBtn) hintBtn.classList.add('hidden');
                if(skipBtn) skipBtn.classList.add('hidden');
            }
        }

        // ----- Summary Page -----
        function showSummary() {
            stopTimer();
            const currentgameAreaEl = gameAreaEl(); const currentNextStageButtonEl = nextStageButtonEl(); const currentSkipStageButtonEl = skipStageButtonEl(); const currentFeedbackSectionEl = feedbackSectionEl(); const currentHintSectionEl = getEl('hint-section');
            if(currentgameAreaEl) currentgameAreaEl.innerHTML = '<h2>üéâ Em ƒë√£ ho√†n th√†nh t·∫•t c·∫£ c√°c th·ª≠ th√°ch! üéâ</h2>';
            if(currentNextStageButtonEl) currentNextStageButtonEl.classList.add('hidden');
            if(currentSkipStageButtonEl) currentSkipStageButtonEl.classList.add('hidden');
            if(currentFeedbackSectionEl) currentFeedbackSectionEl.style.display = 'none';
            if(currentHintSectionEl) currentHintSectionEl.style.display = 'none';

            const summaryPage = summaryPageEl();
            if (summaryPage) {
                getEl('summary-player-name').textContent = playerName || "H·ªçc vi√™n";
                getEl('summary-time').textContent = gameResults.totalTime;
                getEl('summary-correct').textContent = gameResults.correct;
                getEl('total-questions-summary').textContent = totalQuestionsInGame;
                getEl('summary-incorrect').textContent = gameResults.incorrect;
                const errorsList = getEl('summary-errors');
                errorsList.innerHTML = '';
                if (gameResults.errors.length > 0) {
                    gameResults.errors.forEach(err => {
                        const li = document.createElement('li');
                        li.innerHTML = `<strong>${err.stage}:</strong> "${err.input}" - <small>${err.issue}</small>`;
                        errorsList.appendChild(li);
                    });
                } else {
                    errorsList.innerHTML = '<li>ü•≥ Tuy·ªát v·ªùi! Kh√¥ng c√≥ l·ªói n√†o ƒë∆∞·ª£c ghi nh·∫≠n.</li>';
                }
                summaryPage.style.display = 'block';
                if (!getEl('restart-button')) {
                    const restartBtn = document.createElement('button');
                    restartBtn.id = 'restart-button';
                    restartBtn.textContent = 'Ch∆°i l·∫°i t·ª´ ƒë·∫ßu üîÅ';
                    restartBtn.addEventListener('click', initGame);
                    summaryPage.appendChild(restartBtn);
                }
                // D√≤ng nh·∫Øc nh·ªü Google Form ƒë√£ ƒë∆∞·ª£c b·ªè
            } else { console.error("Summary page element not found!"); }
        }

        // ----- Initialization -----
        // MOVED initGame and its DOMContentLoaded listener to the END
        function initGame() {
            console.log("Initializing game: B√†i 1 - ËÆ§ËØÜÊñ∞ÂêåÂ≠¶");
            gameStages = [
                loadVocabMatchingStage_B1,    loadVocabFillStage_B1_Set1,   loadVocabFillStage_B1_Set2,
                loadSentenceCompletionStage_B1, loadReadingCompStage_B1_A,    loadReadingCompStage_B1_B,
                loadReadingCompStage_B1_C,    loadSentenceCreationStage_B1, loadParagraphWritingStage_B1
            ];
            currentStage = 0; totalQuestionsInGame = 0;
            gameResults = { correct: 0, incorrect: 0, errors: [], totalTime: '00:00' };
            playerName = "";
            if (timerInterval) clearInterval(timerInterval); timerInterval = null;
            const currentTimerEl = timerEl(); if(currentTimerEl) currentTimerEl.textContent = '00:00';
            const currentgameContainerEl = gameContainerEl(); const currentsummaryPageEl = summaryPageEl(); const currentgameAreaEl = gameAreaEl(); const currentNextStageButtonEl = nextStageButtonEl(); const currentSkipStageButtonEl = skipStageButtonEl(); const currentInstructionsEl = instructionsEl();

            if(currentgameContainerEl) currentgameContainerEl.classList.remove('hidden');
            if(currentsummaryPageEl) currentsummaryPageEl.style.display = 'none';
            if(currentgameAreaEl) { currentgameAreaEl.innerHTML = ''; delete currentgameAreaEl.dataset.questionsCounted_sc_b1; delete currentgameAreaEl.dataset.questionsCounted_rcA; delete currentgameAreaEl.dataset.questionsCounted_rcB; delete currentgameAreaEl.dataset.questionsCounted_rcC; delete currentgameAreaEl.dataset.questionsCounted_pw_b1; }
            clearFeedback(); clearHint();

            if(currentNextStageButtonEl) { currentNextStageButtonEl.classList.add('hidden'); if (!currentNextStageButtonEl.dataset.listenerAttached) { currentNextStageButtonEl.addEventListener('click', loadNextStage); currentNextStageButtonEl.dataset.listenerAttached = 'true';}}
            if(currentSkipStageButtonEl) { currentSkipStageButtonEl.classList.remove('hidden'); if (!currentSkipStageButtonEl.dataset.listenerAttached) { currentSkipStageButtonEl.addEventListener('click', () => { console.log(`Skipping stage ${currentStage}`); loadNextStage(); }); currentSkipStageButtonEl.dataset.listenerAttached = 'true'; } }

            if (currentInstructionsEl) setInstructions("üëã Ch√†o b·∫°n! Vui l√≤ng nh·∫≠p t√™n ƒë·ªÉ b·∫Øt ƒë·∫ßu b√†i h·ªçc \"ËÆ§ËØÜÊñ∞ÂêåÂ≠¶\".");
            if (currentgameAreaEl) {
                currentgameAreaEl.innerHTML = ` <div id="player-info" style="margin-bottom: 15px; padding: 20px; background-color: #e0f7fa; border-radius: 8px;"> <label for="player-name" style="display: block; margin-bottom: 8px; font-weight: bold;">T√™n c·ªßa b·∫°n:</label> <input type="text" id="player-name" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n..." required style="width: calc(100% - 22px); padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;"> <button id="start-game-button" style="padding: 10px 20px;">B·∫Øt ƒë·∫ßu!</button> </div> `;
                const startButton = getEl('start-game-button'); const playerNameInput = getEl('player-name');
                if (startButton && playerNameInput) {
                    playerNameInput.addEventListener('keypress', function(event) { if (event.key === 'Enter') { event.preventDefault(); startButton.click(); } });
                    startButton.addEventListener('click', () => {
                        const name = playerNameInput.value.trim();
                        if (!name) { alert("Vui l√≤ng nh·∫≠p t√™n c·ªßa b·∫°n!"); return; }
                        playerName = name; console.log("Player Name:", playerName);
                        startTimer();
                        loadNextStage();
                    });
                }
            }
            const currentHintButtonEl = hintButtonEl();
            if (currentHintButtonEl && !currentHintButtonEl.dataset.listenerAttached) { currentHintButtonEl.addEventListener('click', showHint); currentHintButtonEl.dataset.listenerAttached = 'true'; }
            else if (currentHintButtonEl) { currentHintButtonEl.classList.add('hidden'); currentHintButtonEl.disabled = false; }
        }

        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
